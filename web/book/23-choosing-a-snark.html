<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Choosing a SNARK - Minimizing Trust, Maximizing Truth</title>


        <!-- Custom HTML head -->
        <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams']}
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          },
          loader: {
            load: ['[tex]/ams']
          }
        };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
          mermaid.initialize({ startOnLoad: false, theme: 'dark' });
        
          document.addEventListener('DOMContentLoaded', function() {
            // Transform mdBook's code blocks into Mermaid-compatible format
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeBlock) {
              const pre = codeBlock.parentElement;
              const div = document.createElement('div');
              div.className = 'mermaid';
              div.textContent = codeBlock.textContent;
              pre.parentElement.replaceChild(div, pre);
            });
            mermaid.run();
          });
        </script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Architecture of Verifiable Secrets - A comprehensive guide to Zero-Knowledge Proofs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="01-the-trust-problem.html"><strong aria-hidden="true">1.</strong> The Trust Problem</a></li><li class="chapter-item expanded "><a href="02-the-alchemical-power-of-polynomials.html"><strong aria-hidden="true">2.</strong> The Alchemical Power of Polynomials</a></li><li class="chapter-item expanded "><a href="03-the-sum-check-protocol.html"><strong aria-hidden="true">3.</strong> The Sum-Check Protocol</a></li><li class="chapter-item expanded "><a href="04-multilinear-extensions.html"><strong aria-hidden="true">4.</strong> Multilinear Extensions</a></li><li class="chapter-item expanded "><a href="05-univariate-polynomials-and-finite-fields.html"><strong aria-hidden="true">5.</strong> Univariate Polynomials and Finite Fields</a></li><li class="chapter-item expanded "><a href="06-commitment-schemes.html"><strong aria-hidden="true">6.</strong> Commitment Schemes</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocols</li><li class="chapter-item expanded "><a href="07-the-gkr-protocol.html"><strong aria-hidden="true">7.</strong> The GKR Protocol</a></li><li class="chapter-item expanded "><a href="08-from-circuits-to-polynomials.html"><strong aria-hidden="true">8.</strong> From Circuits to Polynomials</a></li><li class="chapter-item expanded "><a href="09-polynomial-commitment-schemes.html"><strong aria-hidden="true">9.</strong> Polynomial Commitment Schemes</a></li><li class="chapter-item expanded "><a href="10-hash-based-commitments-and-fri.html"><strong aria-hidden="true">10.</strong> Hash-Based Commitments and FRI</a></li><li class="chapter-item expanded affix "><li class="part-title">SNARK Construction</li><li class="chapter-item expanded "><a href="11-the-snark-recipe.html"><strong aria-hidden="true">11.</strong> The SNARK Recipe</a></li><li class="chapter-item expanded "><a href="12-groth16.html"><strong aria-hidden="true">12.</strong> Groth16</a></li><li class="chapter-item expanded "><a href="13-plonk.html"><strong aria-hidden="true">13.</strong> PLONK</a></li><li class="chapter-item expanded "><a href="14-lookup-arguments.html"><strong aria-hidden="true">14.</strong> Lookup Arguments</a></li><li class="chapter-item expanded "><a href="15-starks.html"><strong aria-hidden="true">15.</strong> STARKs</a></li><li class="chapter-item expanded affix "><li class="part-title">Zero-Knowledge</li><li class="chapter-item expanded "><a href="16-sigma-protocols.html"><strong aria-hidden="true">16.</strong> Sigma Protocols</a></li><li class="chapter-item expanded "><a href="17-the-zero-knowledge-property.html"><strong aria-hidden="true">17.</strong> The Zero-Knowledge Property</a></li><li class="chapter-item expanded "><a href="18-making-proofs-zero-knowledge.html"><strong aria-hidden="true">18.</strong> Making Proofs Zero-Knowledge</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="19-fast-sum-check-proving.html"><strong aria-hidden="true">19.</strong> Fast Sum-Check Proving</a></li><li class="chapter-item expanded "><a href="20-minimizing-commitment-costs.html"><strong aria-hidden="true">20.</strong> Minimizing Commitment Costs</a></li><li class="chapter-item expanded "><a href="21-the-two-classes-of-piops.html"><strong aria-hidden="true">21.</strong> The Two Classes of PIOPs</a></li><li class="chapter-item expanded "><a href="22-composition-and-recursion.html"><strong aria-hidden="true">22.</strong> Composition and Recursion</a></li><li class="chapter-item expanded "><a href="23-choosing-a-snark.html" class="active"><strong aria-hidden="true">23.</strong> Choosing a SNARK</a></li><li class="chapter-item expanded affix "><li class="part-title">Broader Context</li><li class="chapter-item expanded "><a href="24-mpc-and-zk-parallel-paths.html"><strong aria-hidden="true">24.</strong> MPC and ZK Parallel Paths</a></li><li class="chapter-item expanded "><a href="25-frontiers-and-open-problems.html"><strong aria-hidden="true">25.</strong> Frontiers and Open Problems</a></li><li class="chapter-item expanded "><a href="26-zk-in-the-cryptographic-landscape.html"><strong aria-hidden="true">26.</strong> ZK in the Cryptographic Landscape</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendix-a-cryptographic-primitives.html"><strong aria-hidden="true">27.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="appendix-b-historical-timeline.html"><strong aria-hidden="true">28.</strong> Historical Timeline</a></li><li class="chapter-item expanded "><a href="appendix-c-field-equations-cheat-sheet.html"><strong aria-hidden="true">29.</strong> Field Equations Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minimizing Trust, Maximizing Truth</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook/edit/main/web/src/23-choosing-a-snark.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-23-choosing-a-snark"><a class="header" href="#chapter-23-choosing-a-snark">Chapter 23: Choosing a SNARK</a></h1>
<p>In 2016, Zcash launched with Groth16. The choice seemed obvious: smallest proofs, fastest verification, mature implementation. But Groth16 required a trusted setup ceremony. Six participants generated randomness, then destroyed their computers. The protocol was secure only if at least one participant was honest. If all six had colluded or been compromised, they could reconstruct the secret, mint unlimited currency, and no one would ever know.</p>
<p>Three years later, the Zcash team switched to Halo 2. No trusted setup. The proofs were larger. The proving was slower. But the existential risk evaporated.</p>
<p>This is the nature of SNARK selection: every choice trades one virtue for another. There is no universal optimum, no &quot;best&quot; system. There is only the right system for your constraints, your threat model, your willingness to accept which category of failure.</p>
<p>The preceding chapters developed a complete toolkit: sum-check protocols, polynomial commitments, arithmetization schemes, zero-knowledge techniques, composition and recursion. Each admits multiple instantiations. The combinations number in the dozens. Each combination produces a system with different properties: proof sizes ranging from 128 bytes to 100 kilobytes, proving times from milliseconds to hours, trust assumptions from ceremony-dependent to fully transparent.</p>
<p>This chapter provides a framework for navigating that landscape. Not a prescription (the field moves too fast for prescriptions) but a map of the territory and a compass for orientation.</p>
<h2 id="the-five-axes-of-trade-off"><a class="header" href="#the-five-axes-of-trade-off">The Five Axes of Trade-off</a></h2>
<p>Every SNARK balances five properties. Improve one, and another suffers. The physics of cryptography permits no free lunch.</p>
<h3 id="proof-size"><a class="header" href="#proof-size">Proof Size</a></h3>
<p>How many bytes cross the wire?</p>
<p>On Ethereum, calldata costs roughly 16 gas per byte. A 128-byte Groth16 proof costs about 2,000 gas in calldata. A 50 KB STARK costs 800,000 gas. That's not a rounding error. That's the difference between a viable product and an economic impossibility.</p>
<p>The spectrum spans three orders of magnitude:</p>
<ul>
<li><strong>Constant-size</strong> (~100-300 bytes): Groth16, PLONK with KZG</li>
<li><strong>Logarithmic</strong> (~1-10 KB): Bulletproofs, Spartan</li>
<li><strong>Polylogarithmic</strong> (~10-100+ KB): STARKs, FRI-based systems</li>
</ul>
<p>For on-chain verification, proof size is often the binding constraint. Everything else is negotiable.</p>
<h3 id="verification-time"><a class="header" href="#verification-time">Verification Time</a></h3>
<p>How fast can the verifier check the proof?</p>
<p>On-chain, verification time translates directly to gas costs. A pairing operation costs roughly 45,000 gas. Groth16 needs 3 pairings. PLONK needs about 10. STARKs replace pairings with hashes, but require many of them.</p>
<p>The hierarchy:</p>
<ul>
<li><strong>Constant-time</strong> (~3 pairings): Groth16</li>
<li><strong>Logarithmic</strong> (~10-20 pairings): PLONK, IPA-based systems</li>
<li><strong>Polylogarithmic</strong> (hash-dominated): STARKs</li>
</ul>
<p>Groth16's 3-pairing verification is hard to beat. Everything else is playing catch-up. But pairings are the first casualty of quantum computers, so &quot;hard to beat&quot; may have an expiration date.</p>
<h3 id="prover-time"><a class="header" href="#prover-time">Prover Time</a></h3>
<p>How fast can an honest prover generate a proof?</p>
<p>For small circuits, this barely matters. For zkVMs processing real programs, it's everything.</p>
<p>Consider a billion-constraint proof. At $O(n)$, with each field operation taking 10 nanoseconds, proving takes about 10 seconds. At $O(n \log n)$, with $\log n \approx 30$, the same proof takes 5 minutes. At $O(n^2)$, it takes 300 years.</p>
<p>The hierarchy:</p>
<ul>
<li><strong>Linear in constraint count</strong>: Sum-check-based systems (Spartan, Lasso, Jolt)</li>
<li><strong>Quasilinear</strong> ($O(n \log n)$): PLONK, Groth16, FFT-dominated systems</li>
<li><strong>Superlinear</strong>: Some theoretical constructions (impractical at scale)</li>
</ul>
<p>The $\log n$ factor seems innocuous. It determines whether a proof finishes during a coffee break or overnight.</p>
<p>But asymptotic complexity tells only half the story. FFT-based provers (Groth16, PLONK) jump randomly through memory, thrashing caches and stalling on RAM latency. Sum-check provers scan linearly, keeping data streaming through the cache hierarchy. At billion-constraint scale, the memory access pattern can matter as much as the operation count.</p>
<h3 id="trust-assumptions"><a class="header" href="#trust-assumptions">Trust Assumptions</a></h3>
<p>What must you trust for security?</p>
<p>The Zcash ceremony involved six participants on three continents. Each generated randomness, contributed to the parameters, then destroyed their machines. One participant used a Faraday cage. Another broadcast from an airplane. The paranoia was justified: if <em>all six</em> colluded or were compromised, they could mint unlimited currency, and the counterfeits would be cryptographically indistinguishable from real coins.</p>
<p>This is the price of trusted setup.</p>
<p>The spectrum:</p>
<ul>
<li><strong>Circuit-specific trusted setup</strong> (Groth16): Each circuit requires its own ceremony. Change the circuit, repeat the ritual.</li>
<li><strong>Universal trusted setup</strong> (PLONK, Marlin): One ceremony supports all circuits up to a size bound. The trust is amortized, not eliminated.</li>
<li><strong>Transparent</strong> (STARKs, Bulletproofs): No trusted setup. Security derives entirely from public-coin randomness and standard assumptions.</li>
</ul>
<p>Transparency eliminates an entire category of catastrophic failure. The cost: larger proofs, sometimes by two orders of magnitude.</p>
<h3 id="post-quantum-security"><a class="header" href="#post-quantum-security">Post-Quantum Security</a></h3>
<p>Will the system survive Shor's algorithm?</p>
<p>Shor's algorithm solves discrete logarithm and factoring in polynomial time on a quantum computer. The day a cryptographically relevant quantum computer boots, every pairing-based SNARK becomes insecure. Groth16 proofs could be forged. KZG commitments could be opened to false values. The entire security model collapses.</p>
<p>The threatened systems:</p>
<ul>
<li>All pairing-based SNARKs (Groth16, KZG-based PLONK)</li>
<li>All discrete-log commitments (Pedersen, Bulletproofs)</li>
</ul>
<p>The resistant systems:</p>
<ul>
<li>Hash-based constructions (STARKs, FRI)</li>
</ul>
<p>When will quantum computers arrive? Estimates range from 10 to 30 years. For a private transaction, that uncertainty is tolerable. For infrastructure meant to last decades (identity systems, legal records, financial settlements), it's a sword hanging overhead.</p>
<h2 id="the-system-landscape"><a class="header" href="#the-system-landscape">The System Landscape</a></h2>
<p>Each major proof system occupies a different position in the trade-off space. None dominates all others. The choice depends on which constraints bind tightest.</p>
<h3 id="groth16-the-incumbent"><a class="header" href="#groth16-the-incumbent">Groth16: The Incumbent</a></h3>
<p>Groth16 has the smallest proofs in the business: 128 bytes, three group elements. Verification requires three pairings. Implementations exist in every language, optimized for every platform, battle-tested across billions of dollars in transactions.</p>
<p>The cost is trust. Every circuit needs its own ceremony. Change one constraint, and the parameters are worthless. The ceremony participants must be trusted absolutely, or the &quot;toxic waste&quot; (the secret randomness) must never be reconstructed.</p>
<p>This combination (minimal proofs, maximal trust) made Groth16 the default for years. It remains dominant for on-chain verification where proof size is the binding constraint and the application can absorb a one-time ceremony.</p>
<h3 id="plonk-the-flexible-middle-ground"><a class="header" href="#plonk-the-flexible-middle-ground">PLONK: The Flexible Middle Ground</a></h3>
<p>PLONK solved Groth16's upgrade problem. A single ceremony generates parameters that work for any circuit up to a size bound. Modify the circuit, keep the same parameters. The trust is amortized across an ecosystem rather than concentrated on a single application.</p>
<p>Proofs grow to 500-2000 bytes. Verification requires more pairings. But the flexibility is transformative: zkEVMs can upgrade their circuits without coordinating new ceremonies. Application developers can iterate without security theater.</p>
<p>Custom gates push PLONK further. Where Groth16 accepts only R1CS, PLONK's constraint system accommodates specialized operations. A hash function that requires 10,000 R1CS constraints might need only 100 Plonkish constraints with a custom gate.</p>
<p>The ecosystem followed. UltraPLONK, TurboPLONK, HyperPLONK. Each variant optimizes a different aspect. The platform became an industry standard for general-purpose proving.</p>
<h3 id="starks-the-transparent-option"><a class="header" href="#starks-the-transparent-option">STARKs: The Transparent Option</a></h3>
<p>STARKs eliminate trust entirely. No ceremony. No toxic waste. No existential risk from compromised participants. Security rests on collision-resistant hashing, nothing more.</p>
<p>The price is size. STARK proofs run 50-100+ KB, sometimes larger. Verification is polylogarithmic rather than constant. For on-chain deployment, this can be prohibitive.</p>
<p>But STARKs offer compensations. Provers approach linear time (FRI folding is remarkably efficient). Post-quantum security is plausible (hash functions resist known quantum attacks). And there's a philosophical clarity: the proof stands alone, answerable only to mathematics.</p>
<p>StarkWare built a company on this trade-off. For rollups processing millions of transactions, the amortized proof cost per transaction becomes negligible. The prover speed matters; the verifier runs once.</p>
<h3 id="bulletproofs-the-pairing-free-path"><a class="header" href="#bulletproofs-the-pairing-free-path">Bulletproofs: The Pairing-Free Path</a></h3>
<p>Bulletproofs occupy a specific niche: transparency without the STARK size explosion. Proofs grow logarithmically (typically 600-700 bytes for range proofs). No trusted setup. No pairings required.</p>
<p>The catch: verification takes linear time in the circuit size. For small circuits (range proofs, confidential transactions), this is acceptable. For large computations, it becomes prohibitive.</p>
<p>Monero adopted Bulletproofs for confidential amounts. The proofs are small enough to fit in transactions, transparent enough to satisfy decentralization purists, and specialized enough for the specific task of range proofs.</p>
<p>But Bulletproofs aren't post-quantum. They rely on discrete log hardness. The same quantum computer that breaks Groth16 breaks Bulletproofs.</p>
<h3 id="sum-check-based-systems-the-new-frontier"><a class="header" href="#sum-check-based-systems-the-new-frontier">Sum-Check-Based Systems: The New Frontier</a></h3>
<p>Spartan. Lasso. Jolt. These systems represent the sum-check renaissance described in Chapters 19-21. Their characteristic: linear-time proving.</p>
<p>For zkVMs proving billion-instruction programs, this isn't an optimization. It's the difference between feasibility and fantasy. A 30× speedup (from $O(n \log n)$ to $O(n)$) determines whether proving takes minutes or hours.</p>
<p>Virtual polynomials minimize commitment costs. Sparse sum-check handles irregular constraint structures naturally. The entire apparatus is optimized for the specific challenge of general-purpose computation.</p>
<p>The trade-offs are familiar: larger proofs (logarithmic, not constant), newer implementations (less battle-tested), multilinear PCS requirements (different tooling). But for the zkVM use case, where prover speed dominates all other concerns, sum-check-based systems are becoming the default choice.</p>
<h2 id="application-specific-guidance"><a class="header" href="#application-specific-guidance">Application-Specific Guidance</a></h2>
<p>Theory meets practice at the application boundary. The abstract trade-offs crystallize into concrete decisions.</p>
<h3 id="blockchain-verification-on-chain"><a class="header" href="#blockchain-verification-on-chain">Blockchain Verification (On-Chain)</a></h3>
<p>The verifier runs on Ethereum, paying gas for every operation. Two costs dominate: calldata (bytes shipped to the chain) and computation (opcodes executed on-chain).</p>
<p>At current gas prices, a 128-byte Groth16 proof costs about 20,000 gas in calldata. Verification adds roughly 150,000 gas for the pairing checks. Total: under 200,000 gas. A simple ETH transfer costs 21,000 gas. The proof verification is economically viable.</p>
<p>A 50 KB STARK costs 800,000 gas in calldata alone. Verification adds another 300,000-500,000 gas. Total: over a million gas. For individual transactions, this is often prohibitive.</p>
<p>The solution: composition. Generate a STARK proof (transparent, fast prover), then wrap it in Groth16 (small proof, cheap verification). The inner STARK provides transparency. The outer Groth16 provides on-chain efficiency. The trust assumption applies only to the wrapper, not the original computation.</p>
<h3 id="zkrollups"><a class="header" href="#zkrollups">zkRollups</a></h3>
<p>Rollups amortize proof costs across thousands of transactions. A proof that costs 200,000 gas becomes 20 gas per transaction when it covers 10,000 transactions. The economics invert: larger proofs become tolerable if they aggregate more computation.</p>
<p>StarkNet uses STARKs directly. The proofs are large (100+ KB), but the amortization across massive batches makes the per-transaction cost negligible. The transparency is a feature, not a compromise.</p>
<p>zkSync and Scroll use Groth16 wrappers around internal proving systems. The outer proof is tiny. The inner system can be whatever works best for their EVM implementation.</p>
<p>The pattern: prover efficiency matters (it runs for every batch), proof size matters less (it amortizes across all transactions in the batch).</p>
<h3 id="zkvms"><a class="header" href="#zkvms">zkVMs</a></h3>
<p>Prove correct execution of arbitrary programs. The circuit is enormous: a single transaction might require billions of constraints.</p>
<p>Jolt uses sum-check with lookup arguments. RISC-Zero uses STARKs with AIR. SP1 uses a hybrid approach. All three optimize obsessively for prover speed.</p>
<p>The constraint: proving must be fast enough that users will wait for it. A 10-second proof is a feature. A 10-minute proof is a bug. A 10-hour proof is a research project, not a product.</p>
<p>Virtual polynomials (Chapter 20) minimize commitment costs. Lookup arguments (Chapter 14) replace expensive constraint checks with table lookups. Everything is oriented toward making the prover faster, because at billion-constraint scale, prover time is the binding constraint.</p>
<p>But on-chain verification still demands small proofs. The pattern that emerged: prove with a STARK (fast, transparent), then wrap in Groth16 (tiny proof, cheap verification). RISC-Zero, SP1, and others follow this architecture. The inner STARK handles billions of constraints with linear-time proving. The outer Groth16 compresses everything to 128 bytes for Ethereum. The trust assumption applies only to the wrapper ceremony, not to the original computation.</p>
<h3 id="privacy-preserving-applications"><a class="header" href="#privacy-preserving-applications">Privacy-Preserving Applications</a></h3>
<p>When zero-knowledge is the point (not just a bonus), implementation quality matters as much as theoretical properties.</p>
<p>Groth16 and PLONK produce ZK proofs with modest overhead. The masking techniques are well-understood. But implementation errors can leak information through timing side channels, error messages, or malformed proof handling.</p>
<p>STARKs require more care. The execution trace is exposed during proving, then masked. The masking must be done correctly. A bug here doesn't crash the system; it silently leaks witnesses. You might never know until the damage is done.</p>
<p>Tornado Cash used Groth16. Zcash used Groth16, then Halo 2. Aztec uses UltraPlonk and Honk (PLONK variants co-developed by the Aztec team). The pattern: mature implementations with extensive auditing, because privacy failures are catastrophic and silent.</p>
<p>The architecture splits into two camps. <strong>Server-side proving</strong> (zkRollups, zkVMs) runs provers on powerful infrastructure. The witness data reaches the server, which generates proofs and posts them on-chain. Privacy comes from the proof hiding witness details from the chain, not from the prover. <strong>Client-side proving</strong> (Aztec, Zcash) runs provers on user devices. Sensitive data never leaves the machine. Only the proof and minimal public inputs reach the network.</p>
<p>Client-side proving constrains system choice dramatically. A browser or mobile device can't match datacenter hardware. Aztec's architecture is instructive: private functions execute locally, requiring proof systems efficient enough for consumer hardware. This rules out anything demanding server-grade resources for reasonable latency.</p>
<h3 id="post-quantum-applications"><a class="header" href="#post-quantum-applications">Post-Quantum Applications</a></h3>
<p>Government identity systems. Land registries. Legal archives. Anything with a 20+ year horizon must consider quantum risk.</p>
<p>The rule is simple: avoid discrete log and pairings. That eliminates Groth16, PLONK with KZG, Bulletproofs, and most established systems.</p>
<p>STARKs remain. Hash-based systems survive Shor's algorithm (though Grover's algorithm reduces their security by roughly half, requiring larger parameters). Lattice-based SNARKs are under active research but aren't production-ready.</p>
<p>For the paranoid: generate proofs with two systems, one classical (for efficiency today) and one post-quantum (for survival tomorrow). Store both. Use the efficient one now; the post-quantum one is insurance.</p>
<h3 id="low-trust-environments"><a class="header" href="#low-trust-environments">Low-Trust Environments</a></h3>
<p>Some contexts admit no trust. Decentralized protocols where no ceremony could satisfy all participants. Adversarial settings where any trust assumption becomes an attack surface. Applications in jurisdictions where ceremony participants could be coerced.</p>
<p>Transparency is the only option. STARKs for large computations, Bulletproofs for smaller ones.</p>
<p>The larger proofs are not a bug. They are the manifestation of a theorem: you cannot simultaneously minimize proof size, eliminate trust, and achieve post-quantum security. Something must give. In low-trust environments, you know what to sacrifice.</p>
<h2 id="the-trade-off-triangle"><a class="header" href="#the-trade-off-triangle">The Trade-Off Triangle</a></h2>
<p>Project managers know the Iron Triangle: Fast, Good, Cheap. Pick two. SNARKs have their own version: <strong>Succinct, Transparent, Fast Proving</strong>. The physics of cryptography enforces the same brutal constraint.</p>
<p>Three properties stand in fundamental tension: <strong>proof size, prover time, and trust assumptions</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Proof Size</th><th>Prover Time</th><th>Trust</th></tr></thead><tbody>
<tr><td>Groth16</td><td>Minimal (128 B)</td><td>Quasilinear</td><td>Maximal (circuit-specific)</td></tr>
<tr><td>PLONK</td><td>Small (500 B)</td><td>Quasilinear</td><td>Moderate (universal)</td></tr>
<tr><td>STARKs</td><td>Large (50+ KB)</td><td>Linear</td><td>None</td></tr>
</tbody></table>
</div>
<p>Pick any two vertices. The third suffers.</p>
<p>This is not a failure of engineering. It's a reflection of information-theoretic and complexity-theoretic constraints. Small proofs require structured commitments. Structured commitments require trusted setup or expensive verification. Fast provers require simple commitment schemes. Simple commitment schemes produce large proofs.</p>
<p>The systems that appear to break this triangle (Halo 2, for instance) achieve it through composition: a transparent inner system wrapped in a succinct outer system, accepting architectural complexity as the price of having it all.</p>
<h2 id="implementation-realities"><a class="header" href="#implementation-realities">Implementation Realities</a></h2>
<p>The best algorithm with a buggy implementation is worse than a mediocre algorithm implemented correctly.</p>
<h3 id="audit-status"><a class="header" href="#audit-status">Audit Status</a></h3>
<p>ZK bugs are silent killers. A soundness error lets attackers forge proofs. A witness leak exposes private data. Neither produces error messages or stack traces. The system works perfectly until someone exploits it.</p>
<p>Zcash's original Sprout implementation had a soundness bug for years. It was discovered by a researcher, not an attacker, and patched quietly. The alternative history, where an attacker found it first, is sobering.</p>
<p>Use audited implementations. Multiple audits are better than one. Fresh audits are better than old ones.</p>
<h3 id="optimization-level"><a class="header" href="#optimization-level">Optimization Level</a></h3>
<p>Groth16 has GPU implementations that achieve 10-100× speedups over CPU. PLONK is catching up. Sum-check systems are newer; optimization is ongoing.</p>
<p>If your application is latency-sensitive, check whether GPU proving exists for your chosen system. If it doesn't, factor in the proving time penalty.</p>
<h3 id="tooling"><a class="header" href="#tooling">Tooling</a></h3>
<p>Circom for Groth16 and PLONK. Cairo for STARKs. Noir for multiple backends. Leo for blockchain-specific applications.</p>
<p>Good tooling is force-multiplied engineering time. Bad tooling is hand-written assembly for constraint systems, which is roughly as pleasant as it sounds.</p>
<h3 id="community"><a class="header" href="#community">Community</a></h3>
<p>Abandoned implementations accumulate bugs. Active communities fix them. Check GitHub activity, not just stars. Recent commits matter more than total contributors.</p>
<h2 id="the-composition-escape-hatch"><a class="header" href="#the-composition-escape-hatch">The Composition Escape Hatch</a></h2>
<p>When no single system fits, compose multiple systems.</p>
<p>The canonical pattern: prove the main computation with a fast-prover system (STARK), then prove &quot;the STARK verification succeeded&quot; with a small-proof system (Groth16).</p>
<p>What you get:</p>
<ul>
<li>STARK's proving speed (applied to the large computation)</li>
<li>STARK's transparency (the inner proof is private; only the outer proof is revealed)</li>
<li>Groth16's proof size (only the wrapper touches the chain)</li>
<li>Groth16's verification speed (three pairings, regardless of inner complexity)</li>
</ul>
<p>What you pay:</p>
<ul>
<li>One additional proving step (the wrapper proof)</li>
<li>Architectural complexity (two proving systems to maintain)</li>
<li>The outer system's trust assumptions (if Groth16 wraps a STARK, you trust the Groth16 ceremony)</li>
</ul>
<p>The economics work when the inner computation is large. Wrapping a million-constraint STARK in Groth16 adds perhaps 50,000 constraints for the STARK verifier. The overhead is 5%. Wrapping a thousand-constraint STARK in Groth16 adds 50× overhead. Composition is for the big computations.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Proof Size</th><th>Verify Time</th><th>Prove Time</th><th>Setup</th><th>Post-Quantum</th></tr></thead><tbody>
<tr><td>Groth16</td><td>~128 B</td><td>3 pairings</td><td>$O(n \log n)$</td><td>Circuit-specific</td><td>No</td></tr>
<tr><td>PLONK+KZG</td><td>~500 B</td><td>~10 pairings</td><td>$O(n \log n)$</td><td>Universal</td><td>No</td></tr>
<tr><td>STARK</td><td>~50-100 KB</td><td>$O(\log^2 n)$ hashes</td><td>$O(n)$</td><td>Transparent</td><td>Yes</td></tr>
<tr><td>Bulletproofs</td><td>~600 B + log</td><td>$O(n)$ exp</td><td>$O(n)$ exp</td><td>Transparent</td><td>No</td></tr>
<tr><td>Spartan</td><td>~log KB</td><td>$O(\log n)$ exp</td><td>$O(n)$</td><td>Transparent</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p><strong>The constraints that matter:</strong></p>
<ol>
<li>
<p><strong>On-chain verification is proof-size constrained.</strong> A 128-byte Groth16 proof costs ~2K gas in calldata. A 50KB STARK costs ~800K gas. For single-transaction proofs, this difference determines viability. Groth16 and PLONK with KZG dominate on-chain applications.</p>
</li>
<li>
<p><strong>Large computations are prover-time constrained.</strong> At billion-constraint scale, the difference between $O(n)$ and $O(n \log n)$ is hours versus minutes. Sum-check systems (Spartan, Lasso, Jolt) and STARKs achieve linear-time proving.</p>
</li>
<li>
<p><strong>Privacy applications are implementation-quality constrained.</strong> ZK bugs are silent: soundness errors let attackers forge proofs, witness leaks expose secrets, and neither produces error messages. Use audited implementations. Aztec's client-side proving model shows that efficiency on consumer hardware matters when sensitive data can't leave the device.</p>
</li>
<li>
<p><strong>Long-lived infrastructure is quantum constrained.</strong> Shor's algorithm breaks discrete log and pairings. For 20+ year horizons (identity systems, legal archives), avoid pairing-based SNARKs. STARKs and hash-based systems survive.</p>
</li>
</ol>
<p><strong>The trade-offs:</strong></p>
<ol start="5">
<li>
<p><strong>The trade-off triangle is fundamental.</strong> Small proofs + fast provers → requires trusted setup (Groth16). Small proofs + transparent → requires slow verification (Bulletproofs). Fast provers + transparent → requires large proofs (STARKs). Pick any two vertices; the third suffers.</p>
</li>
<li>
<p><strong>Composition is the escape hatch.</strong> Prove with a STARK (fast, transparent), wrap in Groth16 (tiny proof, cheap verification). zkVMs like RISC-Zero and SP1 use this pattern: the inner STARK handles billions of constraints; the outer Groth16 compresses to 128 bytes for Ethereum. The trust assumption applies only to the wrapper.</p>
</li>
</ol>
<p><strong>The practical considerations:</strong></p>
<ol start="7">
<li>
<p><strong>Audit status matters more than theoretical properties.</strong> Zcash's Sprout had a soundness bug for years. The alternative history where an attacker found it first is sobering. Multiple recent audits beat theoretical elegance.</p>
</li>
<li>
<p><strong>Tooling determines development velocity.</strong> Circom for Groth16/PLONK. Cairo for STARKs. Noir for multiple backends. Good tooling is force-multiplied engineering time; bad tooling is hand-written constraint assembly.</p>
</li>
</ol>
<p><strong>The fundamental insight:</strong></p>
<ol start="9">
<li><strong>No universal winner exists.</strong> Applications have different binding constraints: proof size, prover time, trust model, quantum resistance, implementation maturity. Identify which constraint binds tightest. The system choice follows.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="22-composition-and-recursion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="24-mpc-and-zk-parallel-paths.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="22-composition-and-recursion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="24-mpc-and-zk-parallel-paths.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
