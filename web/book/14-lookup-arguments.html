<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lookup Arguments - Minimizing Trust, Maximizing Truth</title>


        <!-- Custom HTML head -->
        <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams']}
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          },
          loader: {
            load: ['[tex]/ams']
          }
        };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
          mermaid.initialize({ startOnLoad: false, theme: 'dark' });
        
          document.addEventListener('DOMContentLoaded', function() {
            // Transform mdBook's code blocks into Mermaid-compatible format
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeBlock) {
              const pre = codeBlock.parentElement;
              const div = document.createElement('div');
              div.className = 'mermaid';
              div.textContent = codeBlock.textContent;
              pre.parentElement.replaceChild(div, pre);
            });
            mermaid.run();
          });
        </script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Architecture of Verifiable Secrets - A comprehensive guide to Zero-Knowledge Proofs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="01-the-trust-problem.html"><strong aria-hidden="true">1.</strong> The Trust Problem</a></li><li class="chapter-item expanded "><a href="02-the-alchemical-power-of-polynomials.html"><strong aria-hidden="true">2.</strong> The Alchemical Power of Polynomials</a></li><li class="chapter-item expanded "><a href="03-the-sum-check-protocol.html"><strong aria-hidden="true">3.</strong> The Sum-Check Protocol</a></li><li class="chapter-item expanded "><a href="04-multilinear-extensions.html"><strong aria-hidden="true">4.</strong> Multilinear Extensions</a></li><li class="chapter-item expanded "><a href="05-univariate-polynomials-and-finite-fields.html"><strong aria-hidden="true">5.</strong> Univariate Polynomials and Finite Fields</a></li><li class="chapter-item expanded "><a href="06-commitment-schemes.html"><strong aria-hidden="true">6.</strong> Commitment Schemes</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocols</li><li class="chapter-item expanded "><a href="07-the-gkr-protocol.html"><strong aria-hidden="true">7.</strong> The GKR Protocol</a></li><li class="chapter-item expanded "><a href="08-from-circuits-to-polynomials.html"><strong aria-hidden="true">8.</strong> From Circuits to Polynomials</a></li><li class="chapter-item expanded "><a href="09-polynomial-commitment-schemes.html"><strong aria-hidden="true">9.</strong> Polynomial Commitment Schemes</a></li><li class="chapter-item expanded "><a href="10-hash-based-commitments-and-fri.html"><strong aria-hidden="true">10.</strong> Hash-Based Commitments and FRI</a></li><li class="chapter-item expanded affix "><li class="part-title">SNARK Construction</li><li class="chapter-item expanded "><a href="11-the-snark-recipe.html"><strong aria-hidden="true">11.</strong> The SNARK Recipe</a></li><li class="chapter-item expanded "><a href="12-groth16.html"><strong aria-hidden="true">12.</strong> Groth16</a></li><li class="chapter-item expanded "><a href="13-plonk.html"><strong aria-hidden="true">13.</strong> PLONK</a></li><li class="chapter-item expanded "><a href="14-lookup-arguments.html" class="active"><strong aria-hidden="true">14.</strong> Lookup Arguments</a></li><li class="chapter-item expanded "><a href="15-starks.html"><strong aria-hidden="true">15.</strong> STARKs</a></li><li class="chapter-item expanded affix "><li class="part-title">Zero-Knowledge</li><li class="chapter-item expanded "><a href="16-sigma-protocols.html"><strong aria-hidden="true">16.</strong> Sigma Protocols</a></li><li class="chapter-item expanded "><a href="17-the-zero-knowledge-property.html"><strong aria-hidden="true">17.</strong> The Zero-Knowledge Property</a></li><li class="chapter-item expanded "><a href="18-making-proofs-zero-knowledge.html"><strong aria-hidden="true">18.</strong> Making Proofs Zero-Knowledge</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="19-fast-sum-check-proving.html"><strong aria-hidden="true">19.</strong> Fast Sum-Check Proving</a></li><li class="chapter-item expanded "><a href="20-minimizing-commitment-costs.html"><strong aria-hidden="true">20.</strong> Minimizing Commitment Costs</a></li><li class="chapter-item expanded "><a href="21-the-two-classes-of-piops.html"><strong aria-hidden="true">21.</strong> The Two Classes of PIOPs</a></li><li class="chapter-item expanded "><a href="22-composition-and-recursion.html"><strong aria-hidden="true">22.</strong> Composition and Recursion</a></li><li class="chapter-item expanded "><a href="23-choosing-a-snark.html"><strong aria-hidden="true">23.</strong> Choosing a SNARK</a></li><li class="chapter-item expanded affix "><li class="part-title">Broader Context</li><li class="chapter-item expanded "><a href="24-mpc-and-zk-parallel-paths.html"><strong aria-hidden="true">24.</strong> MPC and ZK Parallel Paths</a></li><li class="chapter-item expanded "><a href="25-frontiers-and-open-problems.html"><strong aria-hidden="true">25.</strong> Frontiers and Open Problems</a></li><li class="chapter-item expanded "><a href="26-zk-in-the-cryptographic-landscape.html"><strong aria-hidden="true">26.</strong> ZK in the Cryptographic Landscape</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendix-a-cryptographic-primitives.html"><strong aria-hidden="true">27.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="appendix-b-historical-timeline.html"><strong aria-hidden="true">28.</strong> Historical Timeline</a></li><li class="chapter-item expanded "><a href="appendix-c-field-equations-cheat-sheet.html"><strong aria-hidden="true">29.</strong> Field Equations Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minimizing Trust, Maximizing Truth</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook/edit/main/web/src/14-lookup-arguments.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-14-lookup-arguments"><a class="header" href="#chapter-14-lookup-arguments">Chapter 14: Lookup Arguments</a></h1>
<p>In 2019, ZK engineers hit a wall.</p>
<p>They wanted to verify standard computer programs, things like SHA-256 or ECDSA signatures, but the circuits were exploding in size. The culprit was the <em>bitwise operation</em>. In a silicon CPU, checking <code>a XOR b</code> takes one cycle. In R1CS arithmetic, it took roughly 30 constraints to decompose the numbers into bits, check the bits, and reassemble them. Trying to verify a 64-bit CPU instruction set was like trying to simulate a Ferrari using only gears made of wood.</p>
<p>Ariel Gabizon and Zachary Williamson realized they didn't need to simulate the gears. They just needed to check the answer key. This realization, that you can replace <em>computation</em> with <em>table lookups</em>, broke the 64-bit wall. It allowed circuits to stop &quot;thinking&quot; about XORs and start &quot;remembering&quot; them.</p>
<p>The insight built on earlier work (Bootle et al.'s 2018 &quot;Arya&quot; paper had explored lookup-style arguments), but Plookup made it practical by repurposing PLONK's permutation machinery. The 65,536 valid 16-bit integers become a table. The $2^{16}$ XOR triples become a table. Membership in these tables costs three constraints, regardless of what the table encodes. The architecture shifted, and complexity moved from constraint logic to precomputed data.</p>
<p>The field accelerated. Hab√∂ck's <strong>LogUp</strong> (2022) replaced grand products with sums of logarithmic derivatives, eliminating sorting overhead and enabling cleaner multi-table arguments. Setty, Thaler, and Wahby's <strong>Lasso</strong> (2023) achieved prover costs scaling with lookups performed rather than table size, enabling tables of size $2^{128}$, large enough to hold the evaluation table of any 64-bit instruction. The &quot;lookup singularity&quot; emerged: a vision of circuits that do nothing but look things up in precomputed tables.</p>
<p>Today, every major zkVM relies on lookups. Cairo, RISC-Zero, SP1, and Jolt prove instruction execution not by encoding CPU semantics in constraints, but by verifying that each instruction's behavior matches its entry in a precomputed table. The paradigm shift is complete: <strong>from logic to data</strong>.</p>
<hr />
<h2 id="the-lookup-problem"><a class="header" href="#the-lookup-problem">The Lookup Problem</a></h2>
<p>Chapter 13 introduced the <strong>grand product argument</strong> for copy constraints in PLONK. The idea: to prove that wire values at positions related by permutation $\sigma$ are equal, compute $\prod_i \frac{a_i + \beta \cdot i + \gamma}{a_i + \beta \cdot \sigma(i) + \gamma}$. If the permutation constraint is satisfied (values at linked positions match), this product telescopes to 1. Lookup arguments generalize this technique from equality to containment, proving not that two multisets are the same, but that one is contained in another.</p>
<p>The formal problem:</p>
<p>Given a multiset $f = {f_1, \ldots, f_n}$ of witness values (the &quot;lookups&quot;) and a public multiset $t = {t_1, \ldots, t_d}$ (the &quot;table&quot;), prove $f \subseteq t$.</p>
<p><strong>Why &quot;lookup&quot;?</strong> Imagine you're proving a circuit that computes XOR. The table $t$ contains all valid XOR triples: $(0,0,0), (0,1,1), (1,0,1), (1,1,0)$. Your circuit claims $a \oplus b = c$ for some witness values. Rather than encoding XOR algebraically, you &quot;look up&quot; the triple $(a,b,c)$ in the table. If it's there, the XOR is correct. The multiset $f$ collects all the triples your circuit needs to verify; the subset claim $f \subseteq t$ says every lookup found a valid entry.</p>
<p><strong>The Dictionary Analogy.</strong> Imagine you want to prove you spelled &quot;Cryptography&quot; correctly. The <em>arithmetic approach</em> would be to write down the rules of English grammar and phonetics, then derive the spelling from first principles. Slow, complex, error-prone. The <em>lookup approach</em> would be to open the Oxford English Dictionary to page 412, point to the word &quot;Cryptography,&quot; and say &quot;there.&quot; The lookup argument is simply proving that your tuple (the word you claim) exists in the set (all valid English words). You don't need to understand <em>why</em> it's valid; you just need to show it's in the book.</p>
<p>A naive approach might compare products: if $\prod (f_i + \gamma) = \prod (t_j + \gamma)$, the multisets are equal. But subset is weaker than equality, since $f$ may use only some table entries, possibly with repetition.</p>
<p>Different lookup protocols solve this problem in different ways. We'll detail <strong>Plookup</strong>'s approach first because it builds directly on PLONK's permutation machinery from Chapter 13. Later sections cover alternatives: LogUp uses logarithmic derivatives (sums instead of products), Lasso exploits table decomposition for sublinear prover costs.</p>
<p><strong>Plookup's insight</strong>: Transform the subset claim into a permutation claim. The construction involves three objects:</p>
<ul>
<li><strong>$f$</strong>: the lookup values (what you're looking up, your witness data)</li>
<li><strong>$t$</strong>: the table (all valid values, public and precomputed)</li>
<li><strong>$s$</strong>: the sorted merge of $f$ and $t$ (auxiliary, constructed by prover)</li>
</ul>
<p>The key is that $s$ encodes <em>how</em> $f$ fits into $t$. If every $f_i$ is in $t$, then $s$ is just $t$ with duplicates inserted at the right places.</p>
<h3 id="plookups-sorted-vector-s"><a class="header" href="#plookups-sorted-vector-s">Plookup's Sorted Vector $s$</a></h3>
<p>Define $s = \text{sort}(f \cup t)$, the concatenation of lookup values and table values, sorted.</p>
<p>If $f \subseteq t$, then every element of $f$ appears somewhere in $t$. In the sorted vector $s$, elements from $f$ &quot;slot in&quot; next to their matching elements from $t$.</p>
<p><strong>Key observation</strong>: For every adjacent pair $(s_i, s_{i+1})$ in $s$, either:</p>
<ol>
<li>$s_i = s_{i+1}$ (a repeated value, meaning some $f_j$ was inserted next to its matching $t_k$), or</li>
<li>$(s_i, s_{i+1})$ is also an adjacent pair in the sorted table $t$</li>
</ol>
<p>If some $f_j \notin t$, then $s$ contains a transition that doesn't exist in $t$, and the check fails.</p>
<p><strong>Example</strong>:</p>
<ul>
<li>Lookups: $f = {2, 5}$</li>
<li>Table: $t = {0, 1, 2, 3, 4, 5, 6, 7}$</li>
<li>Sorted: $s = {0, 1, 2, 2, 3, 4, 5, 5, 6, 7}$</li>
</ul>
<p>Adjacent pairs in $s$: $(0,1), (1,2), (2,2), (2,3), (3,4), (4,5), (5,5), (5,6), (6,7)$</p>
<p>The pairs $(2,2)$ and $(5,5)$ are repeats; these correspond to the lookups. All other pairs appear as adjacent pairs in $t$. The subset claim holds.</p>
<p>If instead $f = {2, 9}$:</p>
<ul>
<li>Sorted: $s = {0, 1, 2, 2, 3, 4, 5, 6, 7, 9}$</li>
<li>The pair $(7, 9)$ is not an adjacent pair in $t$</li>
<li>The subset claim fails</li>
</ul>
<h3 id="plookups-grand-product-check"><a class="header" href="#plookups-grand-product-check">Plookup's Grand Product Check</a></h3>
<p>The adjacent-pair property translates to a polynomial identity via a grand product. The construction is clever, so let's build it step by step.</p>
<p><strong>The core idea</strong>: Encode each adjacent pair $(s_i, s_{i+1})$ as a single field element $\gamma(1+\beta) + s_i + \beta s_{i+1}$. The term $\beta$ acts as a &quot;separator&quot;: different pairs map to different field elements (with high probability over random $\beta$). If we multiply all these pair-encodings together, we get a fingerprint of the multiset of adjacent pairs.</p>
<p><strong>$G(\beta, \gamma)$</strong>, the fingerprint of $s$'s adjacent pairs:</p>
<p>$$G(\beta, \gamma) = \prod_{i=1}^{n+d-1} (\gamma(1 + \beta) + s_i + \beta s_{i+1})$$</p>
<p>This is just the product of all adjacent-pair encodings in the sorted vector $s$.</p>
<p><strong>$F(\beta, \gamma)$</strong>, the fingerprint we <em>expect</em> if $f \subseteq t$:</p>
<p>$$F(\beta, \gamma) = (1 + \beta)^n \cdot \prod_{i=1}^{n} (\gamma + f_i) \cdot \prod_{i=1}^{d-1} (\gamma(1 + \beta) + t_i + \beta t_{i+1})$$</p>
<p>Where does this come from? Think about what $s$ looks like when $f \subseteq t$. The sorted merge contains the table $t$ as a &quot;backbone,&quot; with lookup values from $f$ inserted as duplicates next to their matches. So the adjacent pairs in $s$ fall into two categories:</p>
<ol>
<li>
<p><strong>Pairs from $t$</strong>: The $d-1$ consecutive pairs $(t_i, t_{i+1})$ from the original table. These appear in $s$ regardless of what $f$ contains; they're the skeleton that $f$ gets merged into.</p>
</li>
<li>
<p><strong>Repeated pairs from inserting $f$</strong>: When a lookup value $f_j$ slots into $s$ next to its matching table entry, we get a repeated pair $(f_j, f_j)$. The encoding of $(v, v)$ is $\gamma(1+\beta) + v + \beta v = (\gamma + v)(1+\beta)$. So each valid lookup contributes $(\gamma + f_j)$ and $(1+\beta)$ to the product.</p>
</li>
</ol>
<p>$F$ is the fingerprint of <em>exactly these pairs</em>, the table backbone plus $n$ valid duplicate insertions. If $G$ (the actual fingerprint of $s$) equals $F$, then $s$ has the right structure: no &quot;bad&quot; transitions like $(7, 9)$ that would appear if some $f_j \notin t$.</p>
<p><strong>Tiny example</strong>: Let's use a 3-element table to see the algebra concretely.</p>
<ul>
<li>Table: $t = {0, 1, 2}$ (so $d = 3$)</li>
<li>Lookups: $f = {1}$ (so $n = 1$)</li>
<li>Sorted merge: $s = {0, 1, 1, 2}$</li>
</ul>
<p><strong>Computing $G$</strong> (fingerprint of $s$'s adjacent pairs):</p>
<p>The pairs in $s$ are: $(0,1), (1,1), (1,2)$. Encode each:</p>
<p>$$G = (\gamma(1+\beta) + 0 + \beta \cdot 1) \cdot (\gamma(1+\beta) + 1 + \beta \cdot 1) \cdot (\gamma(1+\beta) + 1 + \beta \cdot 2)$$
$$= (\gamma(1+\beta) + \beta) \cdot (\gamma(1+\beta) + 1 + \beta) \cdot (\gamma(1+\beta) + 1 + 2\beta)$$</p>
<p><strong>Computing $F$</strong> (expected fingerprint):</p>
<ul>
<li>Table pairs $(t_i, t_{i+1})$: $(0,1)$ and $(1,2)$</li>
<li>Lookup duplicate: $f_1 = 1$ contributes $(\gamma + 1)(1+\beta)$</li>
</ul>
<p>$$F = (1+\beta)^1 \cdot (\gamma + 1) \cdot (\gamma(1+\beta) + 0 + \beta \cdot 1) \cdot (\gamma(1+\beta) + 1 + \beta \cdot 2)$$
$$= (1+\beta)(\gamma + 1) \cdot (\gamma(1+\beta) + \beta) \cdot (\gamma(1+\beta) + 1 + 2\beta)$$</p>
<p><strong>Why $F = G$?</strong> Notice that the pair $(1,1)$ in $G$ encodes as $\gamma(1+\beta) + 1 + \beta = (\gamma + 1)(1 + \beta)$. This factors! So $G$'s middle term equals $F$'s $(1+\beta)(\gamma+1)$ term. The other two terms match directly. The products are identical.</p>
<p><strong>Claim (Plookup)</strong>: $F \equiv G$ if and only if $f \subseteq t$ and $s$ is correctly formed.</p>
<p>The logic: if every $f_j$ is in $t$, then $s$ is just $t$ with duplicates inserted, and the multiset of adjacent pairs in $s$ equals exactly what $F$ encodes. If some $f_j \notin t$, it creates a &quot;bad&quot; pair in $s$ that doesn't appear in $F$, and the products differ.</p>
<h2 id="the-plookup-protocol"><a class="header" href="#the-plookup-protocol">The Plookup Protocol</a></h2>
<p>The grand product machinery above is <strong>Plookup</strong>, the 2020 protocol by Gabizon and Williamson that launched the lookup paradigm. It's not the only way to build lookup arguments. LogUp replaces grand products with logarithmic derivatives (sums instead of products), eliminating the need for the sorted vector $s$ and enabling cleaner multi-table arguments. Lasso restructures the problem entirely, achieving prover costs that scale with lookups performed rather than table size. We focus on Plookup because it builds directly on PLONK's permutation machinery from Chapter 13, making the connection between copy constraints and lookup arguments explicit.</p>
<p>We now formalize Plookup as integrated with PLONK.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p><strong>Public table</strong>: Polynomial $t(X)$ encoding table values, preprocessed into selector commitments.</p>
<p><strong>Witness values</strong>: The prover has values ${f_1, \ldots, f_n}$ to look up.</p>
<h3 id="prover-computation"><a class="header" href="#prover-computation">Prover Computation</a></h3>
<ol>
<li>
<p><strong>Construct $s$</strong>: Sort $f \cup t$ to obtain the $(f,t)$-sorted vector.</p>
</li>
<li>
<p><strong>Split $s$ into $h_1, h_2$</strong>: The sorted vector $s$ has length $n + d$ (lookups plus table), but PLONK's domain has size $n$. We can't fit $s$ into a single polynomial over this domain. So split $s$ into two halves: $h_1$ encodes the first half, $h_2$ the second. The constraint system will check adjacent pairs <em>within</em> each half and <em>across</em> the boundary where they meet.</p>
</li>
<li>
<p><strong>Commit</strong>: Send $[h_1]_1, [h_2]_1$ to the verifier.</p>
</li>
<li>
<p><strong>Receive challenges</strong>: After Fiat-Shamir, obtain $\beta, \gamma$.</p>
</li>
<li>
<p><strong>Build accumulator</strong>: Construct $Z(X)$ satisfying:</p>
<ul>
<li>$Z(\omega) = 1$</li>
<li>Recursive relation linking $Z(X\omega)$ to $Z(X)$ via the $F/G$ terms</li>
</ul>
</li>
<li>
<p><strong>Commit</strong>: Send $[Z]_1$.</p>
</li>
</ol>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<p>The following polynomial identities are added to the PLONK quotient polynomial:</p>
<p><strong>Accumulator initialization</strong>:
$$(Z(X) - 1) \cdot L_1(X) = 0$$</p>
<p><strong>Accumulator recursion</strong>:
$$Z(X\omega) \cdot \prod_{j \in {1,2}} (\gamma(1+\beta) + h_j(X) + \beta h_j(X\omega))$$
$$= Z(X) \cdot (1+\beta)^m \cdot (\gamma + f(X)) \cdot (\gamma(1+\beta) + t(X) + \beta t(X\omega))$$</p>
<p>where $m$ depends on how many lookups occur per gate (typically 1 or 2).</p>
<p><strong>Accumulator finalization</strong>: The accumulator returns to 1 at the end of the domain (enforced implicitly by the product structure).</p>
<p><strong>Permutation check</strong>: $h_1$ and $h_2$ contain exactly the elements of $f \cup t$, verified via a standard PLONK permutation argument.</p>
<p><strong>Sorting check</strong>: Adjacent elements of $s$ satisfy $s_{i+1} \geq s_i$, typically enforced via a small range check on differences.</p>
<p><strong>Wait, why isn't sorting enough?</strong> If $s$ is sorted, doesn't that prove $f \subseteq t$? Not quite. We also need to prove that $s$ contains <em>exactly</em> the elements of $f$ and $t$, no more, no less. This is the role of the permutation argument.</p>
<p>The complete logic is:</p>
<ol>
<li>$s$ is a permutation of $(f \cup t)$. (So no new numbers appeared out of thin air.)</li>
<li>$s$ is sorted. (So duplicates are adjacent.)</li>
<li>Every adjacent pair in $s$ is valid (either a repeat, or a step that exists in the table).</li>
</ol>
<p>If all three hold, then every element in $f$ must have found a matching buddy in $t$. A cheating prover cannot slip in a value that's not in the table, because it would create an invalid adjacent pair that neither repeats nor exists as a table step.</p>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>The verifier checks the batched PLONK constraints. No table-size-dependent work: verification cost is independent of $d$.</p>
<h2 id="worked-example-plookup-3-bit-range-check"><a class="header" href="#worked-example-plookup-3-bit-range-check">Worked Example: Plookup 3-Bit Range Check</a></h2>
<p>Let's trace through a complete Plookup proof.</p>
<p><strong>Statement</strong>: Prover knows $f_1 = 2$ and $f_2 = 5$, both in $[0, 7]$.</p>
<p><strong>Table</strong>: $t = {0, 1, 2, 3, 4, 5, 6, 7}$, size $d = 8$.</p>
<p><strong>Lookups</strong>: $f = {2, 5}$, size $n = 2$.</p>
<h3 id="step-1-construct-s"><a class="header" href="#step-1-construct-s">Step 1: Construct $s$</a></h3>
<p>$$s = \text{sort}({2, 5} \cup {0, 1, 2, 3, 4, 5, 6, 7}) = {0, 1, 2, 2, 3, 4, 5, 5, 6, 7}$$</p>
<p>Length: $n + d = 10$.</p>
<h3 id="step-2-adjacent-pairs"><a class="header" href="#step-2-adjacent-pairs">Step 2: Adjacent Pairs</a></h3>
<p>Pairs in $s$:
$(0,1), (1,2), (2,2), (2,3), (3,4), (4,5), (5,5), (5,6), (6,7)$</p>
<p>Nine pairs total.</p>
<p>Pairs in sorted $t$:
$(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7)$</p>
<p>Seven pairs.</p>
<p>The pairs $(2,2)$ and $(5,5)$ are repeats from inserting $f$ values. All others match $t$.</p>
<h3 id="step-3-grand-product-identity"><a class="header" href="#step-3-grand-product-identity">Step 3: Grand Product Identity</a></h3>
<p>Using challenges $\beta, \gamma$:</p>
<p><strong>$F(\beta, \gamma)$</strong>, the expected fingerprint:</p>
<p>$$F = (1+\beta)^2 \cdot (\gamma + 2)(\gamma + 5) \cdot \prod_{i=0}^{6} (\gamma(1+\beta) + t_i + \beta t_{i+1})$$</p>
<p>The three parts: $(1+\beta)^2$ for two lookups, $(\gamma + 2)(\gamma + 5)$ for the lookup values, and the seven table pairs $(0,1), (1,2), \ldots, (6,7)$.</p>
<p><strong>$G(\beta, \gamma)$</strong>, the actual fingerprint of $s$'s nine adjacent pairs:</p>
<p>$$G = \prod_{i=0}^{8} (\gamma(1+\beta) + s_i + \beta s_{i+1})$$</p>
<p>Writing out the pairs from $s = {0,1,2,2,3,4,5,5,6,7}$:</p>
<p>$$(0,1), (1,2), (2,2), (2,3), (3,4), (4,5), (5,5), (5,6), (6,7)$$</p>
<p>The key observation: the repeated pairs $(2,2)$ and $(5,5)$ factor specially.</p>
<ul>
<li>$(2,2)$ encodes as $\gamma(1+\beta) + 2 + 2\beta = \gamma(1+\beta) + 2(1+\beta) = (\gamma + 2)(1+\beta)$</li>
<li>$(5,5)$ encodes as $(\gamma + 5)(1+\beta)$</li>
</ul>
<p>So $G$ contains the factors $(\gamma + 2)(1+\beta) \cdot (\gamma + 5)(1+\beta) = (1+\beta)^2 (\gamma+2)(\gamma+5)$.</p>
<p>The remaining seven pairs in $G$, namely $(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7)$, are exactly the table pairs in $F$.</p>
<p>Therefore $F = G$. The lookup succeeds.</p>
<h3 id="step-4-accumulator-trace"><a class="header" href="#step-4-accumulator-trace">Step 4: Accumulator Trace</a></h3>
<p>The accumulator $Z(X)$ starts at 1 and processes one fraction per domain point.</p>
<p>At each step:
$$Z(\omega^{i+1}) = Z(\omega^i) \cdot \frac{\text{$F$ terms at position $i$}}{\text{$G$ terms at position $i$}}$$</p>
<p>If $f \subseteq t$, the numerator and denominator terms are permutations of each other across the full domain. The product telescopes to 1.</p>
<h3 id="code-plookup-grand-product-check"><a class="header" href="#code-plookup-grand-product-check">Code: Plookup Grand Product Check</a></h3>
<p>The following Python demonstrates the core Plookup identity. When lookups are valid, $F = G$. When a lookup is invalid, the fingerprints diverge.</p>
<pre><code class="language-python">def encode_pair(a, b, beta, gamma):
    &quot;&quot;&quot;Encode adjacent pair (a, b) as a field element.&quot;&quot;&quot;
    return gamma * (1 + beta) + a + beta * b

def plookup_check(lookups, table, beta=2, gamma=5):
    &quot;&quot;&quot;
    Verify lookups is a subset of table via Plookup grand product.

    Args:
        lookups: List of values being looked up
        table: Sorted list of valid table entries

    Returns: (F, G, valid) where F and G are the fingerprints
    &quot;&quot;&quot;
    # Construct the sorted merge s = sort(lookups union table)
    s = sorted(lookups + table)

    # G: fingerprint of s's adjacent pairs
    G = 1
    for i in range(len(s) - 1):
        G *= encode_pair(s[i], s[i+1], beta, gamma)

    # F: expected fingerprint if lookups subset of table
    # F = (1+beta)^n * product of (gamma + f_i) * product of table pairs
    n = len(lookups)
    F = (1 + beta) ** n

    for f in lookups:
        F *= (gamma + f)

    for i in range(len(table) - 1):
        F *= encode_pair(table[i], table[i+1], beta, gamma)

    return F, G, (F == G)

# Example 1: Valid lookups {2, 5} into table {0,1,2,3,4,5,6,7}
F, G, valid = plookup_check([2, 5], list(range(8)))
print(f&quot;Valid lookups:   F={F}, G={G}, F==G: {valid}&quot;)

# Example 2: Invalid lookup (9 not in table)
F, G, valid = plookup_check([2, 9], list(range(8)))
print(f&quot;Invalid lookups: F={F}, G={G}, F==G: {valid}&quot;)

# Example 3: Repeated valid lookups
F, G, valid = plookup_check([3, 3, 3], list(range(8)))
print(f&quot;Repeated valid:  F={F}, G={G}, F==G: {valid}&quot;)
</code></pre>
<p>Output:</p>
<pre><code>Valid lookups:   F=563374005, G=563374005, F==G: True
Invalid lookups: F=614965890, G=447828498, F==G: False
Repeated valid:  F=12754584, G=12754584, F==G: True
</code></pre>
<p>The identity holds for valid lookups (including repetitions) and fails for invalid ones. In the real protocol, the check happens via polynomial commitments over a finite field, but the algebraic structure is identical.</p>
<h2 id="plookup-cost-analysis"><a class="header" href="#plookup-cost-analysis">Plookup Cost Analysis</a></h2>
<p><strong>Without lookups</strong> (bit decomposition for two 3-bit range checks):</p>
<ul>
<li>6 bitness constraints + 2 reconstruction = 8 constraints</li>
</ul>
<p><strong>With lookups</strong>:</p>
<ul>
<li>2 lookups, each ~3 constraints (the Plookup overhead)</li>
<li>Table of size 8 adds no verification cost</li>
</ul>
<p>For small ranges, the savings are modest. The power appears at scale.</p>
<p><strong>16-bit range check</strong>:</p>
<ul>
<li>Without: 17 constraints per check</li>
<li>With: ~3 constraints per check</li>
</ul>
<p><strong>8-bit XOR</strong>:</p>
<ul>
<li>Without: ~25 constraints</li>
<li>With: ~3 constraints (one lookup into a $256 \times 256$ table)</li>
</ul>
<p>The table size ($65,536$ entries for 16-bit range or 8-bit XOR) is precomputed and committed once. Lookups against it are cheap.</p>
<h2 id="multiple-tables-and-structured-lookups"><a class="header" href="#multiple-tables-and-structured-lookups">Multiple Tables and Structured Lookups</a></h2>
<p>Real circuits need multiple lookup tables:</p>
<ul>
<li>Range tables of various sizes</li>
<li>XOR tables for different bit widths</li>
<li>Opcode tables for VM verification</li>
<li>Custom function tables (e.g., $\sin$, $\exp$ approximations)</li>
</ul>
<p><strong>Multi-table extensions</strong>: Modern systems (cq, Halo2 lookups) support multiple tables efficiently. The prover specifies which table each lookup targets; the grand product extends to handle the multiplexing.</p>
<p><strong>Structured tables</strong>: Some tables have algebraic structure (e.g., ${0, 1, \ldots, 2^{16}-1}$ is an arithmetic sequence). Specialized arguments exploit this structure for better performance.</p>
<h2 id="comparison-custom-gates-vs-lookup-tables"><a class="header" href="#comparison-custom-gates-vs-lookup-tables">Comparison: Custom Gates vs. Lookup Tables</a></h2>
<p>Both mechanisms extend PLONK beyond vanilla gates. They address different problems.</p>
<h3 id="custom-gates"><a class="header" href="#custom-gates">Custom Gates</a></h3>
<p>A custom gate adds terms to the universal gate equation:</p>
<p>$$Q_L a + Q_R b + Q_O c + Q_M ab + Q_{\text{pow5}} a^5 + Q_C = 0$$</p>
<p>The new selector $Q_{\text{pow5}}$ enables efficient fifth-power computation (useful for Poseidon S-boxes).</p>
<p><strong>Strengths</strong>:</p>
<ul>
<li>No table precomputation</li>
<li>No additional polynomial commitments</li>
<li>Native for algebraic relations</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>The relation must be low-degree</li>
<li>A degree-$2^{16}$ polynomial for range checks is infeasible</li>
</ul>
<p><strong>Best for</strong>: Compact algebraic operations such as boolean checks ($x^2 - x = 0$), elliptic curve point operations, and specialized hash function components.</p>
<h3 id="lookup-tables"><a class="header" href="#lookup-tables">Lookup Tables</a></h3>
<p>A lookup table is a separate mechanism:</p>
<ul>
<li>Precompute valid tuples</li>
<li>Prove witness tuples appear in the table</li>
</ul>
<p><strong>Strengths</strong>:</p>
<ul>
<li>Handles non-algebraic operations</li>
<li>Table size is independent of verification cost</li>
<li>One table serves all lookups against it</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>Adds polynomial commitments to the proof</li>
<li>Requires sorting and permutation checks</li>
<li>Tables must fit in memory</li>
</ul>
<p><strong>Best for</strong>: Range checks, bitwise operations, state machine transitions, arbitrary function approximations.</p>
<h3 id="when-to-use-which"><a class="header" href="#when-to-use-which">When to Use Which</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Problem</th><th>Custom Gate</th><th>Lookup Table</th></tr></thead><tbody>
<tr><td>Boolean check ($x \in {0,1}$)</td><td>Ideal</td><td>Overkill</td></tr>
<tr><td>8-bit range check</td><td>Possible</td><td>Efficient</td></tr>
<tr><td>64-bit range check</td><td>Impractical</td><td>Essential</td></tr>
<tr><td>XOR/AND/OR operations</td><td>Complex</td><td>Clean</td></tr>
<tr><td>Poseidon $x^5$</td><td>One gate</td><td>Unnecessary</td></tr>
<tr><td>Valid opcode check</td><td>Complex</td><td>Direct</td></tr>
</tbody></table>
</div>
<p>Modern systems use both. UltraPLONK combines custom gates (for algebraic primitives) with lookup tables (for non-algebraic constraints).</p>
<h2 id="alternative-lookup-protocols"><a class="header" href="#alternative-lookup-protocols">Alternative Lookup Protocols</a></h2>
<p>Plookup was seminal but not unique. Several alternatives offer different trade-offs.</p>
<h3 id="logup-the-logarithmic-derivative-approach"><a class="header" href="#logup-the-logarithmic-derivative-approach">LogUp: The Logarithmic Derivative Approach</a></h3>
<p>LogUp represents a significant evolution from Plookup. Instead of grand products, it uses the identity:</p>
<p>$$\sum_{i=1}^{n} \frac{1}{\gamma + f_i} = \sum_{j=1}^{d} \frac{m_j}{\gamma + t_j}$$</p>
<p>where $m_j$ is the multiplicity, counting how many times table entry $t_j$ appears in the lookups $f$.</p>
<p><strong>The key insight</strong>: If $f \subseteq t$ with multiplicities, then summing the reciprocals of $(\gamma + f_i)$ over all lookups must equal summing $m_j / (\gamma + t_j)$ over table entries. The multiplicity $m_j$ counts how many lookups reference $t_j$.</p>
<p><strong>Why this matters</strong>:</p>
<ol>
<li>
<p><strong>No sorting required.</strong> Plookup requires constructing and committing to the sorted vector $s$. LogUp skips this entirely: no sorted polynomial, no sorting constraints.</p>
</li>
<li>
<p><strong>Additive structure.</strong> Products become sums of fractions. This enables:</p>
<ul>
<li>Simpler multi-table handling (just add the sums)</li>
<li>Natural integration with sum-check protocols</li>
<li>Easier batching of multiple lookup arguments</li>
</ul>
</li>
<li>
<p><strong>Better cross-table lookups.</strong> When a circuit uses multiple tables (range, XOR, opcodes), LogUp handles them in a unified sum rather than separate grand products.</p>
</li>
</ol>
<p><strong>LogUp-GKR</strong>: Combines LogUp with the GKR protocol for even greater efficiency. The multiplicities $m_j$ are verified via sum-check rather than explicit commitment, reducing prover work for large tables.</p>
<p><strong>The equation in protocol form</strong>:</p>
<p>Define:
$$h(X) = \sum_{i: f(\omega^i) = f_i} \frac{1}{\gamma + f(\omega^i)} - \sum_{j} \frac{m_j}{\gamma + t_j}$$</p>
<p>If the lookup is valid, $h(X)$ sums to zero over the domain. This is verified via sum-check or a grand sum argument.</p>
<h3 id="cq-cached-quotients"><a class="header" href="#cq-cached-quotients">cq (Cached Quotients)</a></h3>
<p>A refinement of the logarithmic derivative approach optimized for repeated lookups.</p>
<p><strong>Advantages</strong>: Pre-computes quotient polynomials for the table. Amortizes table processing across multiple lookup batches.</p>
<p><strong>Trade-offs</strong>: Setup overhead; benefits emerge with many lookups against the same table.</p>
<h3 id="caulk-and-caulk"><a class="header" href="#caulk-and-caulk">Caulk and Caulk+</a></h3>
<p>Caulk (2022) asked a different question: what if the table is <em>huge</em> but you only perform a few lookups? Plookup's prover work scales linearly with table size, making it impractical for tables of size $2^{30}$ or larger.</p>
<p><strong>The insight</strong>: Preprocess the table into a KZG commitment. When the prover looks up values, they prove the lookup values exist in the committed table <em>without</em> touching the entire table during proving.</p>
<p><strong>How it works</strong>: The table polynomial $t(X)$ is committed during setup. For each lookup, the prover constructs a &quot;witness&quot; polynomial that proves the lookup value is a root of a polynomial derived from $t$. The key is using the structure of KZG to make these proofs small and fast.</p>
<p><strong>Complexity</strong>: Prover work is $O(m^2 + m \log N)$ for $m$ lookups into a table of size $N$, sublinear in $N$ when $m \ll N$.</p>
<p><strong>Trade-off</strong>: Requires trusted setup (KZG). More complex than Plookup. The quadratic term in $m$ limits scalability for many lookups.</p>
<p><strong>Caulk+</strong> refined this to $O(m^2)$ prover complexity, removing the $\log N$ term entirely. The table size effectively disappears from prover cost.</p>
<h3 id="halo2-lookups"><a class="header" href="#halo2-lookups">Halo2 Lookups</a></h3>
<p>Halo2, developed by the Electric Coin Company (Zcash), integrates lookups natively with a &quot;permutation argument&quot; variant rather than Plookup's grand product.</p>
<p><strong>The approach</strong>: Instead of sorting and checking adjacent pairs, Halo2 uses a <em>shuffle argument</em>. The prover demonstrates that the multiset of lookups (with multiplicities) is a permutation of a subset of the table (with appropriate multiplicities).</p>
<p><strong>Key differences from Plookup</strong>:</p>
<ul>
<li>No explicit sorted vector $s$</li>
<li>Multiplicities are handled via a separate &quot;permutation&quot; polynomial</li>
<li>Tighter integration with Halo2's recursive verification model</li>
</ul>
<p><strong>In practice</strong>: Halo2's lookup API lets developers define tables declaratively. The proving system handles the constraint generation automatically. This made Halo2 popular for application circuits: you specify <em>what</em> to look up, not <em>how</em> the lookup argument works.</p>
<p><strong>Ecosystem</strong>: Scroll, Taiko, and other L2s built on Halo2 rely on its lookup system for zkEVM implementation.</p>
<h3 id="the-memory-bottleneck"><a class="header" href="#the-memory-bottleneck">The Memory Bottleneck</a></h3>
<p>All the protocols above share a fundamental limitation: <strong>the prover must commit to polynomials whose degree scales with table size</strong>.</p>
<p>For Plookup, the sorted vector $s$ has length $n + d$ (lookups plus table). For LogUp, the multiplicity polynomial has degree $d$. For Caulk, the table polynomial $t(X)$ must be committed during setup. In every case, a table of size $2^{20}$ means million-coefficient polynomials. A table of size $2^{64}$ means polynomials with more coefficients than atoms in a grain of sand.</p>
<p>This is the memory bottleneck. It's not just &quot;expensive&quot;; it's a hard wall. The evaluation table of a 64-bit ADD instruction has $2^{128}$ entries. No computer can store that polynomial, let alone commit to it.</p>
<p>Early zkVMs worked around this by using small tables (8-bit or 16-bit operations) and paying the cost in constraint complexity for larger operations. A 64-bit addition became a cascade of 8-bit additions with carry propagation. It worked, but it was slow.</p>
<p>Lasso breaks through this wall entirely.</p>
<h3 id="lasso-and-jolt"><a class="header" href="#lasso-and-jolt">Lasso and Jolt</a></h3>
<p>Lasso (2023, Setty-Thaler-Wahby) represents the solution to the memory bottleneck: prover costs that scale with <em>lookups performed</em> rather than <em>table size</em>.</p>
<p><strong>Read-Only vs. Read-Write.</strong> Before diving into the mechanism, distinguish two types of lookups:</p>
<p><em>Static tables (read-only)</em>: Fixed functions like XOR, range checks, or AES S-boxes. The table never changes during execution. Plookup, LogUp, and Lasso excel here.</p>
<p><em>Dynamic tables (read-write)</em>: Simulating RAM (random access memory). The table starts empty and fills up as the program runs. This requires different techniques (like memory-checking arguments or timestamp-based permutation checks) because the table itself is witness-dependent. Jolt uses specialized protocols called Twist and Shout for this.</p>
<p>Lasso focuses on static tables, but its decomposition insight is what makes truly large tables tractable.</p>
<p><strong>Lasso's insight</strong>: <em>Decomposable tables</em>. Many tables have structure: their MLE (multilinear extension) can be written as a weighted sum of smaller subtables:</p>
<p>$$\tilde{T}(y) = \sum_{j=1}^{\alpha} c_j \cdot \tilde{T}<em>j(y</em>{S_j})$$</p>
<p>Each subtable $\tilde{T}_j$ looks at only a small chunk of the total input $y$. This &quot;Structure of Sums&quot; (SoS) property enables dramatic efficiency gains.</p>
<p><strong>Example: 64-bit AND.</strong> The conceptual table has $2^{128}$ entries (all pairs of 64-bit inputs). But bitwise AND decomposes perfectly: split inputs into sixteen 4-bit chunks, perform 16 lookups into a tiny 256-entry <code>AND_4</code> table, concatenate results. The prover never touches the $2^{128}$-entry table.</p>
<p><strong>The technical machinery</strong>: Lasso builds on <strong>Spark</strong>, a commitment scheme for sparse polynomials from the Spartan protocol. The key insight: a lookup trace is a <em>sparse</em> &quot;hit&quot; vector. If you perform $m$ lookups into a table of size $N$, you access only $m$ entries. Lasso represents this sparse access pattern using Spark, then proves correctness via sum-check.</p>
<p>The prover's witnesses are:</p>
<ul>
<li><strong>$\tilde{E}(y)$</strong>: The &quot;existence&quot; polynomial (1 if index $y$ was accessed, 0 otherwise)</li>
<li><strong>$\tilde{a}(y)$</strong>: The values looked up at each accessed index</li>
<li><strong>${\tilde{M}_{V,j}}$</strong>: Coefficient polynomials that correctly wire subtable results together</li>
</ul>
<p>The verifier never sees the full table. For structured tables, she can evaluate $\tilde{T}(r)$ at a random challenge point in $O(\log N)$ time using the table's algebraic formula.</p>
<p><strong>Prover costs</strong>: For $m$ lookups into a table decomposed into $c$ chunks with subtables of size $N^{1/c}$:</p>
<p>$$\text{Committed elements} \approx 3cm + \alpha N^{1/c}$$</p>
<p>Crucially, most committed values are <em>small integers</em> (counts in ${0, \ldots, m}$). Committing to small scalars is dramatically faster than random field elements; this is Lasso's performance breakthrough.</p>
<hr />
<p><strong>Jolt</strong> applies Lasso to build a complete zkVM for RISC-V. The philosophy: replace arithmetization of instruction semantics with lookups.</p>
<p>Consider the <code>JOLT_V</code> table, the evaluation table of the entire RISC-V instruction set:</p>
<p>$$\text{JOLT_V}(\text{opcode}, a, b) = f_{\text{op}}(a, b)$$</p>
<p>For a 64-bit machine with 256 opcodes, this table has $2^{136}$ entries. Storing it is physically impossible.</p>
<p><strong>Jolt's insight</strong>: This giant table is <em>decomposable</em>. A 64-bit ADD decomposes into 16 lookups into 4-bit addition subtables. A 64-bit XOR decomposes into 16 independent 4-bit XOR lookups. The subtables are tiny (256 entries each), pre-computed once, and reused for every instruction.</p>
<p><strong>Jolt's architecture</strong>:</p>
<ol>
<li><strong>Lasso for instruction semantics</strong>: Proves that each instruction's output matches its subtable lookups. No arithmetization of CPU logic.</li>
<li><strong>Spartan (R1CS) for wiring</strong>: Proves the simple algebraic relationships (program counter updates, register consistency, data flow between components)</li>
<li><strong>Specialized memory protocols</strong>: <strong>Twist</strong> handles RAM consistency (LOAD/STORE); <strong>Shout</strong> ensures instructions are fetched from the committed bytecode</li>
</ol>
<p><strong>Why this hybrid?</strong> Arithmetizing a 64-bit XOR in R1CS requires 64+ constraints (bit decomposition, per-bit logic). Jolt proves it with 16 cheap lookups. But simple wiring constraints (&quot;this value flows from register to ALU&quot;) are trivial in R1CS. Use each tool where it excels.</p>
<p><strong>Performance</strong>: Jolt achieves roughly 50,000 cycles per RISC-V instruction, orders of magnitude faster than prior zkVMs. The &quot;lookup singularity&quot; becomes real: proving a VM is just proving structured table lookups.</p>
<p><strong>Trade-offs</strong>: Requires decomposable table structure. Arbitrary tables (like SHA-256, which is intentionally non-linear) don't benefit. But for CPU instruction sets, the structure is natural: most operations are bitwise or arithmetic with clean chunk decompositions.</p>
<p>The field continues evolving. The core insight (reducing set membership to polynomial identity) admits many instantiations, each optimizing for different table sizes, structures, and use cases.</p>
<h2 id="integration-with-starks"><a class="header" href="#integration-with-starks">Integration with STARKs</a></h2>
<p>Lookup arguments aren't exclusive to PLONK. STARK-based systems integrate them via the AIR (Algebraic Intermediate Representation) framework.</p>
<p>In AIR terms:</p>
<ul>
<li>The lookup table becomes a public column in the trace</li>
<li>Witness values to be looked up appear in other columns</li>
<li>A running product column accumulates the grand product</li>
<li>Transition constraints enforce the recursive relation</li>
</ul>
<p>The conceptual structure is identical; the implementation adapts to the STARK trace model rather than PLONK's polynomial commitments.</p>
<p>Modern STARK systems (Cairo, RISC0, SP1) rely heavily on lookup arguments for efficient VM verification.</p>
<h2 id="the-role-in-zkvms"><a class="header" href="#the-role-in-zkvms">The Role in zkVMs</a></h2>
<p>Lookup arguments are foundational for zero-knowledge virtual machines.</p>
<p>A zkVM proves correct execution of arbitrary programs. The &quot;table&quot; encodes valid instruction semantics:</p>
<ul>
<li>Opcode validity</li>
<li>Memory read/write consistency</li>
<li>Bitwise operation results</li>
<li>Range checks on registers</li>
</ul>
<p>Without lookups, encoding these constraints algebraically would explode the circuit size. With lookups, each instruction verification reduces to a few table membership proofs.</p>
<p><strong>Example</strong>: Verifying a RISC-V ADD instruction.</p>
<ul>
<li>Without lookups: Decompose 32-bit operands, verify carry propagation, reconstruct result (dozens of constraints).</li>
<li>With lookups: Single lookup proving $(a, b, a+b \mod 2^{32})$ is in the addition table (3 constraints).</li>
</ul>
<p>The efficiency gain is multiplicative across millions of instructions. zkVMs would be impractical without lookup arguments.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p><strong>General principles</strong> (apply to all lookup arguments):</p>
<ol>
<li>
<p><strong>Lookup arguments shift complexity from logic to data</strong>: Precompute valid tuples; prove membership rather than computation. This is the core insight shared by Plookup, LogUp, Lasso, and all variants.</p>
</li>
<li>
<p><strong>The formal problem</strong>: Given lookups $f$ and table $t$, prove $f \subseteq t$. Different protocols reduce this multiset inclusion to different polynomial identities.</p>
</li>
<li>
<p><strong>Cost structure</strong>: Lookup-based proofs achieve roughly constant cost per lookup, independent of the logical complexity of what the table encodes. A 16-bit range check or an 8-bit XOR costs the same as a simple membership test.</p>
</li>
<li>
<p><strong>Complements custom gates</strong>: Lookups handle non-algebraic constraints; custom gates handle algebraic primitives. Modern systems (UltraPLONK, Halo2) use both.</p>
</li>
<li>
<p><strong>zkVM foundation</strong>: Without lookup arguments, verifying arbitrary computation at scale would be infeasible. Every major zkVM relies on lookups for instruction semantics.</p>
</li>
</ol>
<p><strong>Plookup-specific mechanics</strong> (the sorted-merge approach from Section 2):</p>
<ol start="6">
<li>
<p><strong>Sorted vector reduction</strong>: Plookup transforms $f \subseteq t$ into a claim about the sorted merge $s = \text{sort}(f \cup t)$.</p>
</li>
<li>
<p><strong>Adjacent pair property</strong>: In Plookup, every consecutive pair in $s$ is either a repeat (from $f$ slotting in) or exists as adjacent in $t$.</p>
</li>
<li>
<p><strong>Grand product identity</strong>: The polynomial identity $F \equiv G$ encodes Plookup's adjacent-pair check. The accumulator $Z(X)$ enforces this recursively, integrating with PLONK's permutation machinery.</p>
</li>
</ol>
<p><strong>Alternative approaches</strong> (different trade-offs):</p>
<ol start="9">
<li>
<p><strong>LogUp</strong> replaces products with sums of logarithmic derivatives: no sorting, cleaner multi-table handling, natural sum-check integration.</p>
</li>
<li>
<p><strong>Lasso</strong> achieves prover costs scaling with lookups performed rather than table size, enabling tables of size $2^{128}$ via decomposition into small subtables.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="13-plonk.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="15-starks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="13-plonk.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="15-starks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
