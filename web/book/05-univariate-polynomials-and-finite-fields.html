<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Univariate Polynomials and Finite Fields - Minimizing Trust, Maximizing Truth</title>


        <!-- Custom HTML head -->
        <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams']}
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          },
          loader: {
            load: ['[tex]/ams']
          }
        };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
          mermaid.initialize({ startOnLoad: false, theme: 'dark' });
        
          document.addEventListener('DOMContentLoaded', function() {
            // Transform mdBook's code blocks into Mermaid-compatible format
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeBlock) {
              const pre = codeBlock.parentElement;
              const div = document.createElement('div');
              div.className = 'mermaid';
              div.textContent = codeBlock.textContent;
              pre.parentElement.replaceChild(div, pre);
            });
            mermaid.run();
          });
        </script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Architecture of Verifiable Secrets - A comprehensive guide to Zero-Knowledge Proofs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="01-the-trust-problem.html"><strong aria-hidden="true">1.</strong> The Trust Problem</a></li><li class="chapter-item expanded "><a href="02-the-alchemical-power-of-polynomials.html"><strong aria-hidden="true">2.</strong> The Alchemical Power of Polynomials</a></li><li class="chapter-item expanded "><a href="03-the-sum-check-protocol.html"><strong aria-hidden="true">3.</strong> The Sum-Check Protocol</a></li><li class="chapter-item expanded "><a href="04-multilinear-extensions.html"><strong aria-hidden="true">4.</strong> Multilinear Extensions</a></li><li class="chapter-item expanded "><a href="05-univariate-polynomials-and-finite-fields.html" class="active"><strong aria-hidden="true">5.</strong> Univariate Polynomials and Finite Fields</a></li><li class="chapter-item expanded "><a href="06-commitment-schemes.html"><strong aria-hidden="true">6.</strong> Commitment Schemes</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocols</li><li class="chapter-item expanded "><a href="07-the-gkr-protocol.html"><strong aria-hidden="true">7.</strong> The GKR Protocol</a></li><li class="chapter-item expanded "><a href="08-from-circuits-to-polynomials.html"><strong aria-hidden="true">8.</strong> From Circuits to Polynomials</a></li><li class="chapter-item expanded "><a href="09-polynomial-commitment-schemes.html"><strong aria-hidden="true">9.</strong> Polynomial Commitment Schemes</a></li><li class="chapter-item expanded "><a href="10-hash-based-commitments-and-fri.html"><strong aria-hidden="true">10.</strong> Hash-Based Commitments and FRI</a></li><li class="chapter-item expanded affix "><li class="part-title">SNARK Construction</li><li class="chapter-item expanded "><a href="11-the-snark-recipe.html"><strong aria-hidden="true">11.</strong> The SNARK Recipe</a></li><li class="chapter-item expanded "><a href="12-groth16.html"><strong aria-hidden="true">12.</strong> Groth16</a></li><li class="chapter-item expanded "><a href="13-plonk.html"><strong aria-hidden="true">13.</strong> PLONK</a></li><li class="chapter-item expanded "><a href="14-lookup-arguments.html"><strong aria-hidden="true">14.</strong> Lookup Arguments</a></li><li class="chapter-item expanded "><a href="15-starks.html"><strong aria-hidden="true">15.</strong> STARKs</a></li><li class="chapter-item expanded affix "><li class="part-title">Zero-Knowledge</li><li class="chapter-item expanded "><a href="16-sigma-protocols.html"><strong aria-hidden="true">16.</strong> Sigma Protocols</a></li><li class="chapter-item expanded "><a href="17-the-zero-knowledge-property.html"><strong aria-hidden="true">17.</strong> The Zero-Knowledge Property</a></li><li class="chapter-item expanded "><a href="18-making-proofs-zero-knowledge.html"><strong aria-hidden="true">18.</strong> Making Proofs Zero-Knowledge</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="19-fast-sum-check-proving.html"><strong aria-hidden="true">19.</strong> Fast Sum-Check Proving</a></li><li class="chapter-item expanded "><a href="20-minimizing-commitment-costs.html"><strong aria-hidden="true">20.</strong> Minimizing Commitment Costs</a></li><li class="chapter-item expanded "><a href="21-the-two-classes-of-piops.html"><strong aria-hidden="true">21.</strong> The Two Classes of PIOPs</a></li><li class="chapter-item expanded "><a href="22-composition-and-recursion.html"><strong aria-hidden="true">22.</strong> Composition and Recursion</a></li><li class="chapter-item expanded "><a href="23-choosing-a-snark.html"><strong aria-hidden="true">23.</strong> Choosing a SNARK</a></li><li class="chapter-item expanded affix "><li class="part-title">Broader Context</li><li class="chapter-item expanded "><a href="24-mpc-and-zk-parallel-paths.html"><strong aria-hidden="true">24.</strong> MPC and ZK Parallel Paths</a></li><li class="chapter-item expanded "><a href="25-frontiers-and-open-problems.html"><strong aria-hidden="true">25.</strong> Frontiers and Open Problems</a></li><li class="chapter-item expanded "><a href="26-zk-in-the-cryptographic-landscape.html"><strong aria-hidden="true">26.</strong> ZK in the Cryptographic Landscape</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendix-a-cryptographic-primitives.html"><strong aria-hidden="true">27.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="appendix-b-historical-timeline.html"><strong aria-hidden="true">28.</strong> Historical Timeline</a></li><li class="chapter-item expanded "><a href="appendix-c-field-equations-cheat-sheet.html"><strong aria-hidden="true">29.</strong> Field Equations Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minimizing Trust, Maximizing Truth</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook/edit/main/web/src/05-univariate-polynomials-and-finite-fields.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-5-univariate-polynomials-and-finite-fields"><a class="header" href="#chapter-5-univariate-polynomials-and-finite-fields">Chapter 5: Univariate Polynomials and Finite Fields</a></h1>
<p>In 1965, James Cooley and John Tukey published a paper that changed the world. They described an algorithm that could compute Fourier transforms in $O(n \log n)$ time instead of $O(n^2)$. This speedup was the difference between impossible and instant. It launched the digital signal processing revolution, enabling everything from MRI machines to JPEG compression.</p>
<p>But they weren't the first.</p>
<p>Years later, historians discovered that Carl Friedrich Gauss had written down the exact same algorithm in 1805, predating Joseph Fourier's foundational work on Fourier analysis by two years. Gauss used it to calculate the orbits of asteroids Pallas and Juno from astronomical observations. He wrote it in Latin in a notebook, but never published it. The algorithm sat dormant for 160 years.</p>
<p>That such a powerful technique could be discovered, forgotten, and rediscovered says something about its naturalness. Once you understand the symmetries of roots of unity, the FFT practically writes itself. And those same symmetries now power zero-knowledge proofs.</p>
<p>This chapter develops the univariate polynomial paradigm: finite fields, roots of unity, and the techniques that make systems like Groth16, PLONK, and STARKs possible. Where Chapter 4 explored multilinear polynomials over the Boolean hypercube, here we explore a single variable of high degree over a very different domain.</p>
<h2 id="finite-fields-the-algebraic-foundation"><a class="header" href="#finite-fields-the-algebraic-foundation">Finite Fields: The Algebraic Foundation</a></h2>
<p>Zero-knowledge proofs live in finite fields. Not the real numbers, not the integers; finite fields, where arithmetic wraps around and every division is exact.</p>
<p>A finite field $\mathbb{F}_p$ consists of the integers ${0, 1, 2, \ldots, p-1}$ with arithmetic modulo a prime $p$. Addition and multiplication work as usual, then you take the remainder when dividing by $p$:</p>
<p>$$3 + 5 = 8 \equiv 1 \pmod 7$$
$$3 \times 5 = 15 \equiv 1 \pmod 7$$</p>
<p>The magic is in division. Every nonzero element has a multiplicative inverse: this is guaranteed because $p$ is prime. (More generally, finite fields exist for any prime power $p^k$, but prime fields $\mathbb{F}_p$ are the simplest case.) In $\mathbb{F}_7$, we have $3^{-1} = 5$ because $3 \times 5 = 15 \equiv 1$. You can divide by any nonzero element, and the result is exact (no fractions, no approximations).</p>
<p>This is why we call it a <em>field</em>. A <em>ring</em> (like the integers $\mathbb{Z}$) lets you add, subtract, and multiply. A <em>field</em> lets you also divide. The integers are not a field because $1/2$ isn't an integer. But in $\mathbb{F}_7$, division always works: $1/2 = 1 \cdot 2^{-1} = 1 \cdot 4 = 4$, since $2 \cdot 4 = 8 \equiv 1$.</p>
<p>The nonzero elements $\mathbb{F}_p^* = {1, 2, \ldots, p-1}$ form a <strong>cyclic group</strong> under multiplication. This is fundamental: there exists a <strong>generator</strong> $g$ such that every nonzero element is some power of $g$.</p>
<p><strong>Example in $\mathbb{F}_7$</strong>: The element $3$ generates everything:</p>
<div class="table-wrapper"><table><thead><tr><th>Power</th><th>$3^k \mod 7$</th></tr></thead><tbody>
<tr><td>$3^1$</td><td>$3$</td></tr>
<tr><td>$3^2$</td><td>$2$</td></tr>
<tr><td>$3^3$</td><td>$6$</td></tr>
<tr><td>$3^4$</td><td>$4$</td></tr>
<tr><td>$3^5$</td><td>$5$</td></tr>
<tr><td>$3^6$</td><td>$1$</td></tr>
</tbody></table>
</div>
<p>Every nonzero element appears exactly once. The powers cycle through all of $\mathbb{F}_7^*$ before returning to 1.</p>
<p>For cryptographic applications, we use primes of 256 bits or more. The field is vast, roughly $2^{256}$ elements, making exhaustive search impossible.</p>
<h2 id="roots-of-unity"><a class="header" href="#roots-of-unity">Roots of Unity</a></h2>
<p>Because $\mathbb{F}_p^*$ is cyclic of order $p-1$, it contains subgroups of every order dividing $p-1$. The most useful are the <strong>roots of unity</strong>.</p>
<p>An element $\omega \in \mathbb{F}_p$ is an <strong>$n$-th root of unity</strong> if $\omega^n = 1$. It's a <strong>primitive</strong> $n$-th root if additionally $\omega^k \neq 1$ for any $0 &lt; k &lt; n$: the smallest positive power that gives 1 is exactly $n$.</p>
<p>If $\omega$ is a primitive $n$-th root, the complete set of $n$-th roots is:</p>
<p>$$H = {1, \omega, \omega^2, \ldots, \omega^{n-1}}$$</p>
<p>This is a subgroup of order $n$. It's the evaluation domain that powers univariate-based SNARKs.</p>
<h3 id="worked-example-fourth-roots-in-mathbbf_17"><a class="header" href="#worked-example-fourth-roots-in-mathbbf_17">Worked Example: Fourth Roots in $\mathbb{F}_{17}$</a></h3>
<p>Take $p = 17$. The multiplicative group has order $16 = 2^4$. Since $4$ divides $16$, fourth roots of unity exist.</p>
<p>Is $\omega = 4$ a primitive fourth root?</p>
<p>$$4^1 = 4$$
$$4^2 = 16 \equiv -1 \pmod{17}$$
$$4^3 = 64 \equiv 13 \equiv -4 \pmod{17}$$
$$4^4 = 256 \equiv 1 \pmod{17}$$</p>
<p>Yes. The fourth roots of unity are:</p>
<p>$$H = {1, 4, 16, 13} = {1, 4, -1, -4}$$</p>
<p>Notice the structure: $4$ and $-4 = 13$ are negatives of each other, as are $1$ and $-1 = 16$. This is not a coincidence.</p>
<h2 id="the-symmetries"><a class="header" href="#the-symmetries">The Symmetries</a></h2>
<p>Roots of unity have two key symmetries that enable fast algorithms.</p>
<h3 id="symmetry-1-squaring-halves-the-group"><a class="header" href="#symmetry-1-squaring-halves-the-group">Symmetry 1: Squaring Halves the Group</a></h3>
<p>When $n$ is even:</p>
<p>$$\omega^{n/2} = -1$$</p>
<p><strong>Why is this true?</strong> Start with the defining property: $\omega^n = 1$. Taking the square root of both sides: $(\omega^{n/2})^2 = 1$. So $\omega^{n/2}$ is a square root of 1. In any field, the square roots of 1 are exactly $1$ and $-1$. But $\omega^{n/2} \neq 1$ because $\omega$ is <em>primitive</em>: its first power to equal 1 is $\omega^n$, not $\omega^{n/2}$. Therefore $\omega^{n/2} = -1$.</p>
<p>This has a remarkable consequence. If you square every element of $H$:</p>
<p>$$(\omega^k)^2 = \omega^{2k}$$</p>
<p>The squares form the $(n/2)$-th roots of unity. And since $(\omega^{k + n/2})^2 = (\omega^k \cdot \omega^{n/2})^2 = (\omega^k)^2 \cdot 1 = (\omega^k)^2$, each square root of unity appears exactly twice.</p>
<p><strong>In $\mathbb{F}_{17}$</strong>: Squaring the fourth roots ${1, 4, 16, 13}$:</p>
<p>$$1^2 = 1, \quad 4^2 = 16, \quad 16^2 = 1, \quad 13^2 = 16$$</p>
<p>The squares are ${1, 16}$: the square roots of unity, each appearing twice.</p>
<h3 id="symmetry-2-opposite-elements-are-negatives"><a class="header" href="#symmetry-2-opposite-elements-are-negatives">Symmetry 2: Opposite Elements are Negatives</a></h3>
<p>Elements half a cycle apart are negatives:</p>
<p>$$\omega^{k + n/2} = \omega^k \cdot \omega^{n/2} = -\omega^k$$</p>
<p><strong>In $\mathbb{F}_{17}$</strong>:</p>
<ul>
<li>$\omega^0 = 1$ and $\omega^2 = 16 = -1$</li>
<li>$\omega^1 = 4$ and $\omega^3 = 13 = -4$</li>
</ul>
<p>These two symmetries, squaring halves the group and opposites are negatives, are the engine of the Fast Fourier Transform.</p>
<h3 id="the-dft-is-polynomial-evaluation"><a class="header" href="#the-dft-is-polynomial-evaluation">The DFT Is Polynomial Evaluation</a></h3>
<p>Here is one of those facts that seems almost too good to be true.</p>
<p>The Discrete Fourier Transform (DFT) is defined as a matrix-vector multiplication. Given a vector $(c_0, c_1, \ldots, c_{n-1})$, the DFT produces a new vector whose $k$-th entry is:</p>
<p>$$\sum_{j=0}^{n-1} c_j \cdot \omega^{jk}$$</p>
<p>where $\omega$ is a primitive $n$-th root of unity.</p>
<p>Now look at polynomial evaluation. Given a polynomial $P(X) = c_0 + c_1 X + \cdots + c_{n-1} X^{n-1}$, evaluate it at $\omega^k$:</p>
<p>$$P(\omega^k) = \sum_{j=0}^{n-1} c_j \cdot (\omega^k)^j = \sum_{j=0}^{n-1} c_j \cdot \omega^{jk}$$</p>
<p>They are identical. The DFT of the coefficient vector <em>is</em> the evaluation vector at roots of unity. This is not a useful analogy or a computational trick. It is a mathematical identity.</p>
<p>The FFT, then, is not &quot;like&quot; converting between polynomial representations. It <em>is</em> converting between polynomial representations. Coefficient form and evaluation form are the two natural bases for the same vector space, and the DFT matrix is the change-of-basis matrix. The FFT is the fast algorithm for this change of basis, made possible by the recursive structure of roots of unity.</p>
<p>This is why the same algorithm appears in signal processing, image compression, and zero-knowledge proofs. They are not merely related applications; they are the same mathematical operation in different disguises.</p>
<h3 id="resonance-a-physical-intuition"><a class="header" href="#resonance-a-physical-intuition">Resonance: A Physical Intuition</a></h3>
<p>There's a reason the Fourier transform appears in both signal processing and cryptographic proofs: both are exploiting the same mathematical structure.</p>
<p>In physics, every oscillating system has <strong>natural frequencies</strong>: the resonant modes where energy flows most efficiently. Strike a bell, and it rings at specific pitches. Pluck a string, and it vibrates in harmonics. These aren't arbitrary; they're the <strong>eigenfrequencies</strong> of the system, determined by its physical structure.</p>
<p>Roots of unity are the eigenfrequencies of the multiplicative group $\mathbb{F}_p^*$.</p>
<p>Just as a physical system has modes that &quot;fit&quot; its boundary conditions, the finite field has elements that &quot;fit&quot; its cyclic structure. The $n$-th roots of unity are exactly the elements whose powers repeat with period $n$; they resonate with the group's multiplicative structure.</p>
<p>The FFT is decomposition into eigenmodes. A polynomial is a sum of monomials, and each monomial interacts differently with roots of unity. The FFT separates these interactions, projecting the polynomial onto each eigenmode. Evaluating a polynomial at all $n$-th roots simultaneously is like decomposing a sound into its frequency components: same mathematics, different interpretation.</p>
<p>This is why operations that are hard in one basis become easy in another. Multiplication of polynomials (convolution in coefficient space) becomes pointwise multiplication in evaluation space. The FFT is a change of basis to the eigenbasis, where operations decouple.</p>
<h2 id="two-representations-of-polynomials"><a class="header" href="#two-representations-of-polynomials">Two Representations of Polynomials</a></h2>
<p>A polynomial of degree less than $n$ can be viewed in two ways.</p>
<p><strong>Coefficient form</strong>: The polynomial is stored as its coefficients.</p>
<p>$$P(X) = c_0 + c_1 X + c_2 X^2 + \cdots + c_{n-1} X^{n-1}$$</p>
<p><strong>Evaluation form</strong>: The polynomial is stored as its values at $n$ distinct points. Using the $n$-th roots of unity:</p>
<p>$$[P(1), P(\omega), P(\omega^2), \ldots, P(\omega^{n-1})]$$</p>
<p>These two forms carry exactly the same information. A polynomial of degree less than $n$ is uniquely determined by its values at any $n$ points (this is Lagrange interpolation). The coefficient form and evaluation form are just two different coordinate systems for the same object.</p>
<p>Why care about evaluation form? In zero-knowledge proofs, constraints are naturally expressed as evaluations. Gate $i$ must satisfy some relation; this becomes: the constraint polynomial $C(X)$ must equal zero at $\omega^i$. The evaluation form directly represents these constraints.</p>
<h3 id="polynomial-evaluation-as-inner-product"><a class="header" href="#polynomial-evaluation-as-inner-product">Polynomial Evaluation as Inner Product</a></h3>
<p>Here's a key observation that bridges polynomials and linear algebra: <strong>evaluating a polynomial is computing an inner product</strong>.</p>
<p>In coefficient form:
$$P(z) = c_0 + c_1 z + c_2 z^2 + \cdots + c_{n-1} z^{n-1} = \langle \vec{c}, \vec{z} \rangle$$</p>
<p>where $\vec{c} = (c_0, c_1, \ldots, c_{n-1})$ is the coefficient vector and $\vec{z} = (1, z, z^2, \ldots, z^{n-1})$ is the &quot;powers of $z$&quot; vector.</p>
<p>In evaluation form, the same polynomial can be written via Lagrange interpolation:
$$P(z) = \sum_{i=0}^{n-1} P(\omega^i) \cdot L_i(z) = \langle \vec{P}, \vec{L}(z) \rangle$$</p>
<p>where $\vec{P} = (P(1), P(\omega), \ldots, P(\omega^{n-1}))$ is the evaluation vector and $\vec{L}(z) = (L_0(z), L_1(z), \ldots, L_{n-1}(z))$ is the vector of Lagrange basis evaluations.</p>
<p>Either way, polynomial evaluation is an inner product. This observation is surprisingly powerful: it means that <strong>committing to a polynomial</strong> (in either form) reduces to <strong>committing to a vector</strong>, and <strong>proving an evaluation</strong> reduces to <strong>proving an inner product claim</strong>. We'll exploit this connection extensively in Chapter 9.</p>
<p><strong>Two ways to commit</strong>: This duality (coefficient form vs evaluation form) manifests directly in polynomial commitment schemes:</p>
<ul>
<li>
<p><strong>KZG</strong> (Chapter 9) commits in coefficient form: $C = g^{f(\tau)} = \prod_i (g^{\tau^i})^{c_i}$. The commitment encodes &quot;evaluate the coefficients at a secret point $\tau$.&quot;</p>
</li>
<li>
<p><strong>FRI</strong> (Chapter 10) commits in evaluation form: a Merkle tree over $[f(1), f(\omega), \ldots, f(\omega^{n-1})]$. The commitment is a hash of all the evaluations.</p>
</li>
</ul>
<p>The FFT is what makes these equivalent: you can convert between representations in $O(n \log n)$ time. But the choice of representation affects everything: proof size, prover cost, setup requirements, and the algebraic tricks available for verification.</p>
<h2 id="the-fast-fourier-transform"><a class="header" href="#the-fast-fourier-transform">The Fast Fourier Transform</a></h2>
<p>Converting between coefficient and evaluation form naively takes $O(n^2)$ operations: you'd compute each of $n$ evaluations, each requiring $O(n)$ work.</p>
<p>The <strong>Fast Fourier Transform (FFT)</strong> does it in $O(n \log n)$. This speedup is essential; without it, the polynomials in modern proof systems would be computationally intractable.</p>
<p>The FFT exploits the symmetries of roots of unity through divide-and-conquer.</p>
<h3 id="the-core-idea"><a class="header" href="#the-core-idea">The Core Idea</a></h3>
<p>Split a polynomial into its even and odd terms:</p>
<p>$$P(X) = P_{\text{even}}(X^2) + X \cdot P_{\text{odd}}(X^2)$$</p>
<p>where:</p>
<ul>
<li>$P_{\text{even}}(Y) = c_0 + c_2 Y + c_4 Y^2 + \cdots$ (even-indexed coefficients)</li>
<li>$P_{\text{odd}}(Y) = c_1 + c_3 Y + c_5 Y^2 + \cdots$ (odd-indexed coefficients)</li>
</ul>
<p>Both have half the degree of $P$.</p>
<p>Now, when we square the $n$-th roots of unity, we get the $(n/2)$-th roots (each appearing twice). So to evaluate $P$ at all of $H$, we:</p>
<ol>
<li>Recursively evaluate $P_{\text{even}}$ and $P_{\text{odd}}$ at the $(n/2)$-th roots</li>
<li>Combine the results</li>
</ol>
<p>The combination uses the antisymmetry property:</p>
<p>$$P(\omega^k) = P_{\text{even}}(\omega^{2k}) + \omega^k \cdot P_{\text{odd}}(\omega^{2k})$$
$$P(\omega^{k + n/2}) = P_{\text{even}}(\omega^{2k}) - \omega^k \cdot P_{\text{odd}}(\omega^{2k})$$</p>
<p>Two evaluations of $P$ from one evaluation each of $P_{\text{even}}$ and $P_{\text{odd}}$: the same work computes both, with just an addition versus subtraction.</p>
<h3 id="worked-example-4-point-fft"><a class="header" href="#worked-example-4-point-fft">Worked Example: 4-Point FFT</a></h3>
<p>Evaluate $P(X) = 5 + 3X + X^2 + 2X^3$ at $H = {1, 4, 16, 13}$ in $\mathbb{F}_{17}$.</p>
<p><strong>Split</strong>:</p>
<ul>
<li>$P_{\text{even}}(Y) = 5 + Y$ (coefficients $c_0 = 5$, $c_2 = 1$)</li>
<li>$P_{\text{odd}}(Y) = 3 + 2Y$ (coefficients $c_1 = 3$, $c_3 = 2$)</li>
</ul>
<p><strong>Evaluate on ${1, 16}$</strong> (the square roots of unity):</p>
<div class="table-wrapper"><table><thead><tr><th>$Y$</th><th>$P_{\text{even}}(Y) = 5 + Y$</th><th>$P_{\text{odd}}(Y) = 3 + 2Y$</th></tr></thead><tbody>
<tr><td>$1$</td><td>$6$</td><td>$5$</td></tr>
<tr><td>$16$</td><td>$21 \equiv 4$</td><td>$35 \equiv 1$</td></tr>
</tbody></table>
</div>
<p><strong>Combine</strong> using $\omega^0 = 1$, $\omega^1 = 4$, $\omega^2 = 16$, $\omega^3 = 13$:</p>
<p>$$P(1) = P_{\text{even}}(1) + 1 \cdot P_{\text{odd}}(1) = 6 + 5 = 11$$
$$P(4) = P_{\text{even}}(16) + 4 \cdot P_{\text{odd}}(16) = 4 + 4 = 8$$
$$P(16) = P_{\text{even}}(1) - 1 \cdot P_{\text{odd}}(1) = 6 - 5 = 1$$
$$P(13) = P_{\text{even}}(16) - 4 \cdot P_{\text{odd}}(16) = 4 - 4 = 0$$</p>
<p><strong>Result</strong>: $[P(1), P(4), P(16), P(13)] = [11, 8, 1, 0]$.</p>
<p>Verification: $P(4) = 5 + 3(4) + 16 + 2(64) = 5 + 12 + 16 + 128 = 161 \equiv 8 \pmod{17}$. Correct.</p>
<p>The inverse FFT, going from evaluations back to coefficients, uses the same algorithm with $\omega^{-1}$ instead of $\omega$ and a factor of $1/n$.</p>
<h2 id="the-vanishing-polynomial"><a class="header" href="#the-vanishing-polynomial">The Vanishing Polynomial</a></h2>
<p>Here is the central insight of univariate arithmetization.</p>
<p>The <strong>vanishing polynomial</strong> of a set $H$ is:</p>
<p>$$Z_H(X) = \prod_{h \in H}(X - h)$$</p>
<p>For the $n$-th roots of unity, this simplifies dramatically:</p>
<p>$$Z_H(X) = X^n - 1$$</p>
<p>This is because $\omega^n = 1$ for every root of unity $\omega$; they are precisely the roots of $X^n - 1$.</p>
<p><strong>The key theorem</strong>: A polynomial $C(X)$ vanishes at every point of $H$ if and only if $Z_H(X)$ divides $C(X)$.</p>
<p>This is the compression at the heart of univariate SNARKs:</p>
<ol>
<li>Encode $n$ constraints as: &quot;$C(\omega^i) = 0$ for all $i$&quot;</li>
<li>This is equivalent to: &quot;$Z_H(X)$ divides $C(X)$&quot;</li>
<li>Which is equivalent to: &quot;There exists $Q(X)$ such that $C(X) = Q(X) \cdot Z_H(X)$&quot;</li>
</ol>
<p>One polynomial divisibility condition captures $n$ separate constraint checks.</p>
<h2 id="the-divisibility-check"><a class="header" href="#the-divisibility-check">The Divisibility Check</a></h2>
<p>How do we verify divisibility efficiently?</p>
<p>The prover computes the quotient $Q(X) = C(X) / Z_H(X)$ and commits to it. The verifier picks a random challenge $z \in \mathbb{F}$ and checks:</p>
<p>$$C(z) \stackrel{?}{=} Q(z) \cdot Z_H(z)$$</p>
<p>If $C(X) = Q(X) \cdot Z_H(X)$ as polynomials, this equation holds for all $z$, including the random one.</p>
<p>If $C(X) \neq Q(X) \cdot Z_H(X)$, their difference is a nonzero polynomial. By Schwartz-Zippel, a random $z$ catches this disagreement with probability at least $1 - d/|\mathbb{F}|$, where $d$ is the degree.</p>
<p>One random check. $n$ constraints verified. This is the magic.</p>
<h2 id="lagrange-interpolation"><a class="header" href="#lagrange-interpolation">Lagrange Interpolation</a></h2>
<p>Given evaluations at roots of unity, how do we recover the polynomial?</p>
<p>The <strong>Lagrange basis polynomial</strong> $L_i(X)$ equals 1 at $\omega^i$ and 0 at all other roots:</p>
<p>$$L_i(X) = \prod_{j \neq i} \frac{X - \omega^j}{\omega^i - \omega^j}$$</p>
<p>The polynomial passing through points $({\omega^i, y_i})$ is:</p>
<p>$$P(X) = \sum_{i=0}^{n-1} y_i \cdot L_i(X)$$</p>
<p>For roots of unity, the Lagrange basis has a beautiful closed form:</p>
<p>$$L_i(X) = \frac{\omega^i}{n} \cdot \frac{X^n - 1}{X - \omega^i}$$</p>
<p>The factor $\frac{X^n - 1}{X - \omega^i}$ vanishes at all roots except $\omega^i$. The prefactor $\frac{\omega^i}{n}$ normalizes to give $L_i(\omega^i) = 1$.</p>
<h2 id="cosets-shifting-the-domain"><a class="header" href="#cosets-shifting-the-domain">Cosets: Shifting the Domain</a></h2>
<p>Sometimes we need evaluation points outside $H$. <strong>Cosets</strong> provide them while preserving structure.</p>
<p>If $k \notin H$ is any nonzero field element, then:</p>
<p>$$k \cdot H = {k, k\omega, k\omega^2, \ldots, k\omega^{n-1}}$$</p>
<p>is a coset of $H$. It's a &quot;shifted&quot; copy: $n$ new points, disjoint from $H$.</p>
<p><strong>Why cosets matter in ZK:</strong> Several proof systems crucially depend on cosets:</p>
<ul>
<li>
<p><strong>PLONK's permutation argument</strong>: Uses multiple cosets to encode wire positions. If you have $n$ gates with 3 wires each ($a$, $b$, $c$), PLONK encodes them on $H$, $kH$, and $k^2H$ (three disjoint domains of size $n$ each). This lets the permutation polynomial distinguish &quot;wire $a$ of gate 5&quot; from &quot;wire $b$ of gate 5.&quot;</p>
</li>
<li>
<p><strong>FRI's low-degree testing</strong>: The prover evaluates on a domain larger than the polynomial's degree (for &quot;rate&quot; or &quot;blowup&quot;). Using $H \cup kH$ doubles the evaluation domain while maintaining FFT structure.</p>
</li>
<li>
<p><strong>Quotient degree management</strong>: If $C(X)$ has degree $2n$ but we've only committed to evaluations on $H$ (size $n$), we need more points to pin down the quotient. Using $H \cup kH$ gives $2n$ points (enough to determine a polynomial of degree less than $2n$).</p>
</li>
</ul>
<p>The FFT works on cosets too: just multiply each root of unity by $k$ before running the algorithm.</p>
<h2 id="the-quotient-argument"><a class="header" href="#the-quotient-argument">The Quotient Argument</a></h2>
<p>A fundamental operation: prove that $P(z) = y$ for a committed polynomial $P$.</p>
<p>The <strong>factor theorem</strong> says: $P(z) = y$ if and only if $(X - z)$ divides $P(X) - y$.</p>
<p>The prover computes:</p>
<p>$$Q(X) = \frac{P(X) - y}{X - z}$$</p>
<p>If $P(z) = y$, this is a polynomial. If not, the division has a remainder; $Q$ isn't a polynomial.</p>
<p>The verifier checks the polynomial identity:</p>
<p>$$P(X) - y = Q(X) \cdot (X - z)$$</p>
<p>at a random point. This is the foundation of KZG opening proofs (Chapter 9).</p>
<h2 id="univariate-vs-multilinear"><a class="header" href="#univariate-vs-multilinear">Univariate vs. Multilinear</a></h2>
<p>We now have two paradigms for polynomial proofs:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Multilinear</th><th>Univariate</th></tr></thead><tbody>
<tr><td><strong>Variables</strong></td><td>$n$ variables, degree 1 each</td><td>1 variable, degree $N-1$</td></tr>
<tr><td><strong>Domain</strong></td><td>Boolean hypercube ${0,1}^n$</td><td>Roots of unity $H$</td></tr>
<tr><td><strong>Size</strong></td><td>$N = 2^n$ points</td><td>$N$ points</td></tr>
<tr><td><strong>Constraint encoding</strong></td><td>Sum over hypercube</td><td>Divisibility by $Z_H$</td></tr>
<tr><td><strong>Key algorithm</strong></td><td>Recursive halving</td><td>FFT</td></tr>
<tr><td><strong>Prover cost</strong></td><td>$O(N)$ (linear)</td><td>$O(N \log N)$ (quasi-linear)</td></tr>
<tr><td><strong>Verification</strong></td><td>Sum-check protocol</td><td>Random evaluation</td></tr>
<tr><td><strong>Systems</strong></td><td>GKR, Spartan, Lasso</td><td>PLONK, Marlin, STARKs</td></tr>
</tbody></table>
</div>
<p>Both achieve the same essential goal: reduce exponentially many constraint checks to a constant number of random evaluations. They're complementary perspectives on the same phenomenon (the rigidity of low-degree polynomials).</p>
<p><strong>A note on Groth16</strong>: Groth16 uses univariate polynomials but doesn't require roots of unity; it encodes constraints via QAP (Quadratic Arithmetic Programs) and verifies satisfaction through pairing equations, not divisibility checks at structured domains. Provers <em>can</em> use FFT as an optimization for polynomial arithmetic, but it's not fundamental to the protocol. PLONK and STARKs, by contrast, rely structurally on roots of unity: constraints are encoded as &quot;polynomial vanishes on $H$,&quot; checked via the divisibility pattern described above.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li>
<p><strong>Finite fields</strong> provide exact arithmetic with every nonzero element invertible. The nonzero elements form a cyclic group.</p>
</li>
<li>
<p><strong>Roots of unity</strong> are elements with $\omega^n = 1$. They form a subgroup of size $n$ when $n$ divides $p-1$.</p>
</li>
<li>
<p><strong>The key symmetries</strong>: Squaring halves the group; opposite elements are negatives. These enable the FFT.</p>
</li>
<li>
<p><strong>Two representations</strong>: Polynomials can be stored as coefficients or evaluations. The FFT converts between them in $O(n \log n)$ time.</p>
</li>
<li>
<p><strong>The vanishing polynomial</strong> $Z_H(X) = X^n - 1$ captures all roots of unity. A polynomial vanishes on $H$ iff $Z_H$ divides it.</p>
</li>
<li>
<p><strong>Constraint compression</strong>: $n$ constraints &quot;$C(\omega^i) = 0$&quot; become one divisibility &quot;$Z_H | C$&quot;, verified by one random check.</p>
</li>
<li>
<p><strong>Lagrange interpolation</strong> over roots of unity has a clean closed form exploiting the structure of $Z_H$.</p>
</li>
<li>
<p><strong>Cosets</strong> extend the domain while preserving FFT-friendliness.</p>
</li>
<li>
<p><strong>Quotient arguments</strong> prove evaluation claims: to show $P(z) = y$, prove $(X-z)$ divides $P(X) - y$.</p>
</li>
<li>
<p><strong>The FFT exists because of roots of unity.</strong> The algorithm is a direct consequence of the symmetries $\omega^{n/2} = -1$ and $(\omega^k)^2 = \omega^{2k}$.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="04-multilinear-extensions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="06-commitment-schemes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="04-multilinear-extensions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="06-commitment-schemes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
