<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Groth16 - Minimizing Trust, Maximizing Truth</title>


        <!-- Custom HTML head -->
        <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams']}
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          },
          loader: {
            load: ['[tex]/ams']
          }
        };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
          mermaid.initialize({ startOnLoad: false, theme: 'dark' });
        
          document.addEventListener('DOMContentLoaded', function() {
            // Transform mdBook's code blocks into Mermaid-compatible format
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeBlock) {
              const pre = codeBlock.parentElement;
              const div = document.createElement('div');
              div.className = 'mermaid';
              div.textContent = codeBlock.textContent;
              pre.parentElement.replaceChild(div, pre);
            });
            mermaid.run();
          });
        </script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Architecture of Verifiable Secrets - A comprehensive guide to Zero-Knowledge Proofs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="01-the-trust-problem.html"><strong aria-hidden="true">1.</strong> The Trust Problem</a></li><li class="chapter-item expanded "><a href="02-the-alchemical-power-of-polynomials.html"><strong aria-hidden="true">2.</strong> The Alchemical Power of Polynomials</a></li><li class="chapter-item expanded "><a href="03-the-sum-check-protocol.html"><strong aria-hidden="true">3.</strong> The Sum-Check Protocol</a></li><li class="chapter-item expanded "><a href="04-multilinear-extensions.html"><strong aria-hidden="true">4.</strong> Multilinear Extensions</a></li><li class="chapter-item expanded "><a href="05-univariate-polynomials-and-finite-fields.html"><strong aria-hidden="true">5.</strong> Univariate Polynomials and Finite Fields</a></li><li class="chapter-item expanded "><a href="06-commitment-schemes.html"><strong aria-hidden="true">6.</strong> Commitment Schemes</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocols</li><li class="chapter-item expanded "><a href="07-the-gkr-protocol.html"><strong aria-hidden="true">7.</strong> The GKR Protocol</a></li><li class="chapter-item expanded "><a href="08-from-circuits-to-polynomials.html"><strong aria-hidden="true">8.</strong> From Circuits to Polynomials</a></li><li class="chapter-item expanded "><a href="09-polynomial-commitment-schemes.html"><strong aria-hidden="true">9.</strong> Polynomial Commitment Schemes</a></li><li class="chapter-item expanded "><a href="10-hash-based-commitments-and-fri.html"><strong aria-hidden="true">10.</strong> Hash-Based Commitments and FRI</a></li><li class="chapter-item expanded affix "><li class="part-title">SNARK Construction</li><li class="chapter-item expanded "><a href="11-the-snark-recipe.html"><strong aria-hidden="true">11.</strong> The SNARK Recipe</a></li><li class="chapter-item expanded "><a href="12-groth16.html" class="active"><strong aria-hidden="true">12.</strong> Groth16</a></li><li class="chapter-item expanded "><a href="13-plonk.html"><strong aria-hidden="true">13.</strong> PLONK</a></li><li class="chapter-item expanded "><a href="14-lookup-arguments.html"><strong aria-hidden="true">14.</strong> Lookup Arguments</a></li><li class="chapter-item expanded "><a href="15-starks.html"><strong aria-hidden="true">15.</strong> STARKs</a></li><li class="chapter-item expanded affix "><li class="part-title">Zero-Knowledge</li><li class="chapter-item expanded "><a href="16-sigma-protocols.html"><strong aria-hidden="true">16.</strong> Sigma Protocols</a></li><li class="chapter-item expanded "><a href="17-the-zero-knowledge-property.html"><strong aria-hidden="true">17.</strong> The Zero-Knowledge Property</a></li><li class="chapter-item expanded "><a href="18-making-proofs-zero-knowledge.html"><strong aria-hidden="true">18.</strong> Making Proofs Zero-Knowledge</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="19-fast-sum-check-proving.html"><strong aria-hidden="true">19.</strong> Fast Sum-Check Proving</a></li><li class="chapter-item expanded "><a href="20-minimizing-commitment-costs.html"><strong aria-hidden="true">20.</strong> Minimizing Commitment Costs</a></li><li class="chapter-item expanded "><a href="21-the-two-classes-of-piops.html"><strong aria-hidden="true">21.</strong> The Two Classes of PIOPs</a></li><li class="chapter-item expanded "><a href="22-composition-and-recursion.html"><strong aria-hidden="true">22.</strong> Composition and Recursion</a></li><li class="chapter-item expanded "><a href="23-choosing-a-snark.html"><strong aria-hidden="true">23.</strong> Choosing a SNARK</a></li><li class="chapter-item expanded affix "><li class="part-title">Broader Context</li><li class="chapter-item expanded "><a href="24-mpc-and-zk-parallel-paths.html"><strong aria-hidden="true">24.</strong> MPC and ZK Parallel Paths</a></li><li class="chapter-item expanded "><a href="25-frontiers-and-open-problems.html"><strong aria-hidden="true">25.</strong> Frontiers and Open Problems</a></li><li class="chapter-item expanded "><a href="26-zk-in-the-cryptographic-landscape.html"><strong aria-hidden="true">26.</strong> ZK in the Cryptographic Landscape</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendix-a-cryptographic-primitives.html"><strong aria-hidden="true">27.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="appendix-b-historical-timeline.html"><strong aria-hidden="true">28.</strong> Historical Timeline</a></li><li class="chapter-item expanded "><a href="appendix-c-field-equations-cheat-sheet.html"><strong aria-hidden="true">29.</strong> Field Equations Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minimizing Trust, Maximizing Truth</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook/edit/main/web/src/12-groth16.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-12-groth16-the-pairing-based-optimal"><a class="header" href="#chapter-12-groth16-the-pairing-based-optimal">Chapter 12: Groth16: The Pairing-Based Optimal</a></h1>
<p>In 2016, when Zcash was preparing to launch, they faced a practical problem. Blockchain transactions are expensive. Every byte costs money. The existing SNARKs (Pinocchio and its descendants) required proofs of nearly 300 bytes. It was workable, but clunky.</p>
<p>Then Jens Groth published a paper that seemed to violate the laws of physics. He shaved the proof down to 128 bytes on BN254. To demonstrate just how small this was, developers realized they could fit an entire zero-knowledge proof, verifying a computation of millions of steps, into a single tweet:</p>
<p><code>[Proof: 0x1a2b3c...] #Zcash</code></p>
<p>This was not just optimization. It was perfection. Groth proved mathematically that for pairing-based systems, you literally cannot get smaller than 3 group elements. He had found the floor.</p>
<p>The paper, &quot;On the Size of Pairing-based Non-interactive Arguments,&quot; became the most deployed SNARK in history. When Zcash launched its Sapling upgrade in 2018, it used Groth16. When Tornado Cash and dozens of other privacy applications needed succinct proofs, they used Groth16. The answer to &quot;what's the smallest possible proof?&quot; turned out to be the answer the entire field needed.</p>
<hr />
<p>The SNARKs we've studied follow a common pattern: construct an IOP, compile it with a polynomial commitment scheme, apply Fiat-Shamir. This modular approach yields flexible systems (swap the PCS, change the trust assumptions) but it leaves efficiency on the table.</p>
<p>Groth16 takes a different path. Rather than instantiating a generic framework, it was designed from first principles to minimize one specific metric: proof size. The result is a proof consisting of exactly three group elements (roughly 128 bytes on standard curves). Verification requires three pairing operations. Nothing smaller exists within the pairing-based paradigm; Groth16 sits at the theoretical minimum for systems of its class.</p>
<p>This optimality comes with constraints. The trusted setup is circuit-specific: change a single gate and you need a new ceremony. The prover cannot be made faster than $O(n \log n)$ without giving up something else. Zero-knowledge requires careful blinding that's woven into the protocol's fabric rather than layered on top.</p>
<p>Understanding Groth16 requires thinking at a different level of abstraction. The three-layer IOP/PCS/Fiat-Shamir decomposition still applies, but the layers are fused: optimized as a unit rather than composed as modules. What we gain is unmatched succinctness. What we pay is inflexibility.</p>
<h2 id="from-r1cs-to-polynomial-identity"><a class="header" href="#from-r1cs-to-polynomial-identity">From R1CS to Polynomial Identity</a></h2>
<p>Chapter 8 introduced R1CS: the prover demonstrates knowledge of a witness vector $Z$ satisfying</p>
<p>$$(A \cdot Z) \circ (B \cdot Z) = C \cdot Z$$</p>
<p>where $A$, $B$, $C$ are matrices encoding the circuit and $\circ$ denotes the Hadamard (element-wise) product. Each row enforces one constraint of the form $(a \cdot Z)(b \cdot Z) = c \cdot Z$.</p>
<p>Groth16's first move is to transform this system of $m$ constraints into a single polynomial identity.</p>
<h3 id="the-qap-transformation"><a class="header" href="#the-qap-transformation">The QAP Transformation</a></h3>
<p>Fix a set of $m$ distinct evaluation points $\omega_1, \ldots, \omega_m$ in the field $\mathbb{F}$. For each column $j$ of the matrices, define polynomials $A_j(X)$, $B_j(X)$, $C_j(X)$ by Lagrange interpolation:</p>
<p>$$A_j(\omega_i) = A_{ij}, \quad B_j(\omega_i) = B_{ij}, \quad C_j(\omega_i) = C_{ij}$$</p>
<p>These are the <strong>basis polynomials</strong>: one for each wire in the circuit. They encode the circuit's structure: which wires participate in which constraints, with what coefficients.</p>
<p>Given witness $Z = (z_0, z_1, \ldots, z_{n-1})$, form the <strong>witness polynomials</strong>:</p>
<p>$$A(X) = \sum_{j=0}^{n-1} z_j \cdot A_j(X), \quad B(X) = \sum_{j=0}^{n-1} z_j \cdot B_j(X), \quad C(X) = \sum_{j=0}^{n-1} z_j \cdot C_j(X)$$</p>
<p>The construction ensures that at each evaluation point $\omega_i$, the witness polynomial $A(\omega_i)$ equals the dot product $A_i \cdot Z$: exactly the value appearing in the $i$-th constraint. The polynomial encapsulates all constraints simultaneously.</p>
<p><strong>The R1CS Condition Becomes a Polynomial Vanishing Condition</strong></p>
<p>The R1CS is satisfied if and only if:</p>
<p>$$A(\omega_i) \cdot B(\omega_i) - C(\omega_i) = 0 \quad \text{for all } i \in {1, \ldots, m}$$</p>
<p>This says the polynomial $P(X) = A(X) \cdot B(X) - C(X)$ vanishes at every $\omega_i$. By the factor theorem, $P(X)$ must be divisible by the <strong>vanishing polynomial</strong>:</p>
<p>$$Z_H(X) = \prod_{i=1}^{m} (X - \omega_i)$$</p>
<p>The R1CS is satisfied if and only if there exists a polynomial $H(X)$, the <strong>quotient</strong> or <strong>cofactor</strong>, such that:</p>
<p>$$A(X) \cdot B(X) - C(X) = H(X) \cdot Z_H(X)$$</p>
<p>This is the <strong>QAP (Quadratic Arithmetic Program) identity</strong>. It compresses $m$ constraint checks into one polynomial divisibility claim.</p>
<h3 id="worked-example-continuing-x3--x--5--35"><a class="header" href="#worked-example-continuing-x3--x--5--35">Worked Example: Continuing $x^3 + x + 5 = 35$</a></h3>
<p>From Chapter 8, we have 5 constraints and 7 witness positions. Let the evaluation points be ${1, 2, 3, 4, 5}$.</p>
<p>The witness is $Z = (1, 35, 3, 9, 27, 30, 35)$ representing $(1, \text{output}, x, x^2, x^3, x^3+x, x^3+x+5)$.</p>
<p>For the second column (corresponding to variable $x$), the column vector in $A$ is $(1, 0, 1, 0, 0)$, representing that $x$ appears in constraints 1 and 3. The basis polynomial $A_2(X)$ interpolates through points $(1, 1), (2, 0), (3, 1), (4, 0), (5, 0)$:</p>
<p>$$A_2(X) = 1 \cdot L_1(X) + 1 \cdot L_3(X)$$</p>
<p>where $L_i(X)$ is the $i$-th Lagrange basis polynomial.</p>
<p>After computing all basis polynomials and forming the witness polynomials, the quotient $H(X)$ exists and has degree $\deg(A \cdot B) - \deg(Z_H) = 2(m-1) - m = m - 2$.</p>
<h2 id="the-core-protocol-idea"><a class="header" href="#the-core-protocol-idea">The Core Protocol Idea</a></h2>
<p>Verifying the QAP identity directly requires evaluating polynomials of degree $O(m)$, far too expensive for succinctness. The Schwartz-Zippel approach suggests evaluating at a random point $\tau$: if $A(\tau) \cdot B(\tau) - C(\tau) = H(\tau) \cdot Z_H(\tau)$, then the identity holds with overwhelming probability.</p>
<p>But the witness polynomials encode the secret witness. We cannot simply send $A(\tau)$ to the verifier.</p>
<p>Groth16 solves this with three ideas working in concert:</p>
<ol>
<li>
<p><strong>Homomorphic hiding</strong>: Evaluate in the exponent. Send $g^{A(\tau)}$ instead of $A(\tau)$.</p>
</li>
<li>
<p><strong>Pairing verification</strong>: Check multiplication via bilinear pairing. The equation $e(g^a, g^b) = e(g, g)^{ab}$ lets the verifier check multiplicative relations on hidden values.</p>
</li>
<li>
<p><strong>Structured randomness</strong>: Embed the check into the trusted setup. The verifier never sees $\tau$; they receive encoded values that enable verification without knowing the secret.</p>
</li>
</ol>
<h3 id="linear-pcps-the-abstraction"><a class="header" href="#linear-pcps-the-abstraction">Linear PCPs: The Abstraction</a></h3>
<p>Groth16 is best understood through the lens of <strong>Linear PCPs</strong> (Probabilistically Checkable Proofs where the proof is a linear function).</p>
<p>In a standard PCP, the verifier queries specific positions of a proof string. In a Linear PCP, the &quot;proof&quot; is a linear function $\pi: \mathbb{F}^k \to \mathbb{F}$, and the verifier queries $\pi(q)$ for chosen query vectors $q$.</p>
<p><strong>The Shadow Puppet Intuition.</strong> Imagine you want to prove your hands are tied in a specific knot, but you cannot show your hands directly (zero-knowledge). In a Linear PCP, the trusted setup is a light source placed at a very specific, secret angle ($\tau$). You hold up your &quot;polynomial&quot; hands. The verifier only sees the shadow on the wall (the group elements).</p>
<p>Because the light source is fixed and secret, you cannot fake the shadow. If the shadow looks like a knot, your hands must be tied. The linearity comes from the fact that you can move your fingers (add group elements), and the shadow moves exactly in sync. But you cannot create shadows that don't correspond to real hand positions.</p>
<p>The critical insight: if the prover must respond with $\pi(q)$ for a linear function $\pi$, and the queries are encrypted as $g^q$, then the response $g^{\pi(q)}$ can be computed homomorphically without knowing $q$.</p>
<p>Groth16's trusted setup embeds carefully chosen query vectors into group elements. The prover computes responses using only scalar multiplication: linear operations on the encrypted queries. The verifier checks a quadratic relation using a single pairing equation.</p>
<p>This is why the proof has exactly three elements: the protocol is optimized around one pairing check (which is quadratic in its inputs), requiring one element from each source group to achieve non-linearity.</p>
<h2 id="the-trusted-setup"><a class="header" href="#the-trusted-setup">The Trusted Setup</a></h2>
<p>Groth16 requires a <strong>Structured Reference String (SRS)</strong> generated by a trusted ceremony. The ceremony has two phases with fundamentally different properties.</p>
<h3 id="phase-1-powers-of-tau-universal"><a class="header" href="#phase-1-powers-of-tau-universal">Phase 1: Powers of Tau (Universal)</a></h3>
<p>A secret random value $\tau \in \mathbb{F}^*$ is chosen. The ceremony outputs encrypted powers:</p>
<p>$${g_1, g_1^{\tau}, g_1^{\tau^2}, \ldots, g_1^{\tau^{d}}} \quad \text{and} \quad {g_2, g_2^{\tau}, g_2^{\tau^2}, \ldots, g_2^{\tau^{d}}}$$</p>
<p>where $d$ is large enough to support circuits up to a certain size.</p>
<p>This phase is <strong>universal</strong>: the same Powers of Tau can be used for any circuit within the size bound. Public ceremonies like &quot;Perpetual Powers of Tau&quot; provide reusable parameters.</p>
<p>The ceremony is a multi-party computation (MPC) with a <strong>1-of-N trust model</strong>. Each participant $i$ chooses secret $t_i$, updates the running parameters by raising to the $t_i$-th power, and deletes $t_i$. The final $\tau = t_1 \cdot t_2 \cdots t_N$ is unknown to everyone provided at least one participant was honest.</p>
<h3 id="phase-2-circuit-specific-secrets"><a class="header" href="#phase-2-circuit-specific-secrets">Phase 2: Circuit-Specific Secrets</a></h3>
<p>Phase 2 generates additional secrets $\alpha, \beta, \gamma, \delta \in \mathbb{F}^*$ that are specific to the circuit being proven. These secrets serve structural roles:</p>
<p><strong>$\alpha$ and $\beta$ (Cross-term cancellation)</strong>: When the prover constructs their proof elements, the verification equation produces &quot;cross-terms&quot; like $\alpha \cdot B(\tau)$. The $\alpha, \beta$ blinding ensures these terms cancel correctly without revealing the witness.</p>
<p><strong>$\gamma$ (Public input binding)</strong>: Separates public from private inputs in the verification equation. The verifier computes a commitment to the public inputs and checks it against the $\gamma$-scaled portion of the SRS.</p>
<p><strong>$\delta$ (Private witness binding)</strong>: Forces the prover to use consistent values across the $A$, $B$, and $C$ polynomials. Without $\delta$, the prover could use different witnesses for different polynomials (a completeness attack).</p>
<h3 id="why-phase-2-cannot-be-universal"><a class="header" href="#why-phase-2-cannot-be-universal">Why Phase 2 Cannot Be Universal</a></h3>
<p>The Phase 2 parameters are not generic encrypted powers; they are <strong>circuit-specific combinations</strong> like:</p>
<p>$$g_1^{\frac{\beta \cdot A_j(\tau) + \alpha \cdot B_j(\tau) + C_j(\tau)}{\delta}}$$</p>
<p>These encode the basis polynomials $A_j, B_j, C_j$ directly. Change the circuit, change the basis polynomials, and these elements no longer make cryptographic sense.</p>
<p>More fundamentally: computing these elements requires knowing $\alpha, \beta, \gamma, \delta$ in the clear. After the ceremony, these secrets are destroyed. They cannot be recovered to compute new circuit-specific values.</p>
<p>This is Groth16's central tradeoff. The circuit-specific encoding enables the minimal proof size. It also mandates a new ceremony for every circuit.</p>
<h2 id="protocol-specification"><a class="header" href="#protocol-specification">Protocol Specification</a></h2>
<p>With setup complete, we specify the prover and verifier algorithms.</p>
<h3 id="common-reference-string"><a class="header" href="#common-reference-string">Common Reference String</a></h3>
<p>The <strong>Proving Key</strong> $\text{pk}$ contains:</p>
<ul>
<li>
<p>Encrypted powers: ${g_1^{\tau^i}}$, ${g_2^{\tau^i}}$</p>
</li>
<li>
<p>Blinding elements: $g_1^{\alpha}$, $g_1^{\beta}$, $g_2^{\beta}$, $g_1^{\delta}$, $g_2^{\delta}$</p>
</li>
<li>
<p>Basis polynomial commitments: ${g_1^{A_j(\tau)}}$, ${g_1^{B_j(\tau)}}$, ${g_2^{B_j(\tau)}}$</p>
</li>
<li>
<p>Consistency check elements for private inputs:</p>
<p>$$\left\lbrace g_1^{\frac{\beta \cdot A_j(\tau) + \alpha \cdot B_j(\tau) + C_j(\tau)}{\delta}} \right\rbrace_{j \in \text{private}}$$</p>
</li>
<li>
<p>Quotient polynomial support: ${g_1^{\tau^i \cdot Z_H(\tau) / \delta}}$</p>
</li>
</ul>
<p>The <strong>Verification Key</strong> $\text{vk}$ contains:</p>
<ul>
<li>
<p>Pairing elements: $g_1^{\alpha}$, $g_2^{\beta}$, $g_2^{\gamma}$, $g_2^{\delta}$</p>
</li>
<li>
<p>Public input consistency elements:</p>
<p>$$\left\lbrace g_1^{\frac{\beta \cdot A_j(\tau) + \alpha \cdot B_j(\tau) + C_j(\tau)}{\gamma}} \right\rbrace_{j \in \text{public}}$$</p>
</li>
</ul>
<h3 id="prover-algorithm"><a class="header" href="#prover-algorithm">Prover Algorithm</a></h3>
<p>Given witness $Z = (1, \text{io}, W)$ where $\text{io}$ are public inputs and $W$ is the private witness:</p>
<ol>
<li>
<p><strong>Compute witness polynomials</strong>: Form $A(X), B(X), C(X)$ from the witness.</p>
</li>
<li>
<p><strong>Compute quotient</strong>: Calculate $H(X) = \frac{A(X) \cdot B(X) - C(X)}{Z_H(X)}$.</p>
</li>
<li>
<p><strong>Generate randomness</strong>: Sample fresh $r, s \leftarrow \mathbb{F}$.</p>
</li>
<li>
<p><strong>Construct proof elements</strong>:</p>
</li>
</ol>
<p>$$\pi_A = g_1^{\alpha + A(\tau) + r\delta}$$</p>
<p>$$\pi_B = g_2^{\beta + B(\tau) + s\delta}$$</p>
<p>$$\pi_C = g_1^{\frac{\sum_{j \in \text{priv}} z_j (\beta A_j(\tau) + \alpha B_j(\tau) + C_j(\tau))}{\delta} + \frac{H(\tau) \cdot Z_H(\tau)}{\delta} + s(\alpha + A(\tau) + r\delta) + r(\beta + B(\tau) + s\delta) - rs\delta}$$</p>
<p>The prover outputs $\pi = (\pi_A, \pi_B, \pi_C) \in \mathbb{G}_1 \times \mathbb{G}_2 \times \mathbb{G}_1$.</p>
<h3 id="proof-size"><a class="header" href="#proof-size">Proof Size</a></h3>
<p>On the BN254 curve:</p>
<ul>
<li>$\pi_A \in \mathbb{G}_1$: 32 bytes (compressed)</li>
<li>$\pi_B \in \mathbb{G}_2$: 64 bytes (compressed)</li>
<li>$\pi_C \in \mathbb{G}_1$: 32 bytes (compressed)</li>
</ul>
<p><strong>Total: 128 bytes.</strong></p>
<p>This is the smallest proof size achieved by any pairing-based SNARK. The paper proves a lower bound: any SNARK in this model requires at least two group elements. Groth16's three elements are close to optimal.</p>
<h3 id="verifier-algorithm"><a class="header" href="#verifier-algorithm">Verifier Algorithm</a></h3>
<p>Given public inputs $\text{io} = (z_0, z_1, \ldots, z_\ell)$ where $z_0 = 1$:</p>
<ol>
<li>
<p><strong>Compute public input combination</strong>:
$$\text{vk}<em>x = \sum</em>{j=0}^{\ell} z_j \cdot (\text{vk}_{IC})<em>j$$
where $(\text{vk}</em>{IC})_j = g_1^{\frac{\beta A_j(\tau) + \alpha B_j(\tau) + C_j(\tau)}{\gamma}}$</p>
</li>
<li>
<p><strong>Check pairing equation</strong>:
$$e(\pi_A, \pi_B) \stackrel{?}{=} e(g_1^{\alpha}, g_2^{\beta}) \cdot e(\text{vk}_x, g_2^{\gamma}) \cdot e(\pi_C, g_2^{\delta})$$</p>
</li>
</ol>
<p>The verifier accepts if the equation holds, rejects otherwise.</p>
<h3 id="verification-cost"><a class="header" href="#verification-cost">Verification Cost</a></h3>
<p>The verification requires:</p>
<ul>
<li>One multi-scalar multiplication in $\mathbb{G}_1$ (size proportional to public input count)</li>
<li>Four pairing computations (or three pairings after rearrangement)</li>
</ul>
<p>Pairings are expensive: roughly 2-3ms each on modern hardware. But the cost is independent of circuit size. A circuit with a million constraints verifies as fast as one with a hundred.</p>
<h2 id="why-the-verification-equation-works"><a class="header" href="#why-the-verification-equation-works">Why the Verification Equation Works</a></h2>
<p>The pairing equation encodes the QAP identity in a way that cancels blinding terms while checking the core constraint.</p>
<h3 id="expanding-the-left-hand-side"><a class="header" href="#expanding-the-left-hand-side">Expanding the Left-Hand Side</a></h3>
<p>$$e(\pi_A, \pi_B) = e(g_1^{\alpha + A(\tau) + r\delta}, g_2^{\beta + B(\tau) + s\delta})$$</p>
<p>Using bilinearity, the exponent in $\mathbb{G}_T$ is:</p>
<p>$$(\alpha + A(\tau) + r\delta)(\beta + B(\tau) + s\delta)$$</p>
<p>Expanding:</p>
<p>$$= \alpha\beta + \alpha B(\tau) + \alpha s\delta + \beta A(\tau) + A(\tau)B(\tau) + A(\tau)s\delta + r\beta\delta + r B(\tau)\delta + rs\delta^2$$</p>
<p>This contains the desired term $A(\tau)B(\tau)$ mixed with cross-terms involving the secrets.</p>
<h3 id="expanding-the-right-hand-side"><a class="header" href="#expanding-the-right-hand-side">Expanding the Right-Hand Side</a></h3>
<p><strong>Term 1</strong>: $e(g_1^{\alpha}, g_2^{\beta})$ contributes exponent $\alpha\beta$.</p>
<p><strong>Term 2</strong>: $e(\text{vk}_x, g_2^{\gamma})$ contributes:</p>
<p>$$\sum_{j \in \text{public}} z_j \cdot (\beta A_j(\tau) + \alpha B_j(\tau) + C_j(\tau))$$</p>
<p>after the $\gamma$ cancels.</p>
<p><strong>Term 3</strong>: $e(\pi_C, g_2^{\delta})$ contributes the private witness consistency check plus:</p>
<p>$$H(\tau) \cdot Z_H(\tau) + s\alpha\delta + sA(\tau)\delta + r\beta\delta + rB(\tau)\delta + rs\delta^2$$</p>
<p>after the $\delta$ cancels from the private terms.</p>
<h3 id="the-cancellation"><a class="header" href="#the-cancellation">The Cancellation</a></h3>
<p>Combining public and private terms:</p>
<p>$$\sum_{\text{all } j} z_j \cdot (\beta A_j(\tau) + \alpha B_j(\tau) + C_j(\tau)) = \beta A(\tau) + \alpha B(\tau) + C(\tau)$$</p>
<p>The RHS exponent becomes:</p>
<p>$$\alpha\beta + \beta A(\tau) + \alpha B(\tau) + C(\tau) + H(\tau)Z_H(\tau) + \alpha s\delta + A(\tau)s\delta + \beta r\delta + B(\tau)r\delta + rs\delta^2$$</p>
<p>Setting LHS = RHS and canceling matching terms (where the following cancel out):</p>
<ul>
<li>$\alpha\beta$ cancels</li>
<li>$\alpha B(\tau)$ cancels</li>
<li>$\beta A(\tau)$ cancels</li>
<li>All $r, s$ terms cancel</li>
</ul>
<p>What remains:</p>
<p>$$A(\tau)B(\tau) = C(\tau) + H(\tau)Z_H(\tau)$$</p>
<p>This is exactly the QAP identity. The elaborate construction of $\pi_C$ exists precisely to provide terms that cancel the blinding while preserving the core check.</p>
<h2 id="security-and-the-generic-group-model"><a class="header" href="#security-and-the-generic-group-model">Security and the Generic Group Model</a></h2>
<p>Groth16's security proof relies on the <strong>Generic Bilinear Group Model</strong>: an idealization where the adversary can only perform group operations without exploiting the specific structure of the underlying curve.</p>
<h3 id="the-model"><a class="header" href="#the-model">The Model</a></h3>
<p>In this model, group elements are represented by opaque handles. The adversary can:</p>
<ul>
<li>Add/subtract group elements</li>
<li>Check equality</li>
<li>Compute pairings</li>
</ul>
<p>The adversary cannot:</p>
<ul>
<li>Look inside a group element to see its discrete log</li>
<li>Exploit number-theoretic structure of the curve</li>
</ul>
<h3 id="what-the-model-implies"><a class="header" href="#what-the-model-implies">What the Model Implies</a></h3>
<p>Under this model, Groth16 is <strong>knowledge-sound</strong>: any adversary that produces a valid proof must &quot;know&quot; a valid witness. More precisely, there exists an extractor that, given the adversary's state, can produce a witness.</p>
<p>The model also implies the proof is <strong>zero-knowledge</strong>: the proof reveals nothing about the witness beyond what follows from the public statement.</p>
<h3 id="the-assumptions-strength"><a class="header" href="#the-assumptions-strength">The Assumption's Strength</a></h3>
<p>The generic group model is non-standard. Real elliptic curves have algebraic structure; real adversaries might exploit it. No attacks are known against Groth16 on standard curves, but the security proof doesn't rule out structure-dependent attacks.</p>
<p>This is the price of efficiency. Schemes provable under weaker assumptions (discrete log, CDH) typically have larger proofs. Groth16 achieves optimal size by assuming more.</p>
<h3 id="concrete-assumptions"><a class="header" href="#concrete-assumptions">Concrete Assumptions</a></h3>
<p>At a technical level, security reduces to the following assumptions:</p>
<ul>
<li><strong>q-Strong Diffie-Hellman (q-SDH)</strong>: Given ${g^{\tau^i}}_{i=0}^{q}$, it's hard to produce $(c, g^{1/(\tau + c)})$ for any $c$.</li>
<li><strong>Knowledge of Exponent</strong>: If an adversary outputs $(g^a, g^{ab})$, they must &quot;know&quot; $a$.</li>
</ul>
<p>These are strong but well-studied assumptions on pairing groups.</p>
<h3 id="proof-malleability"><a class="header" href="#proof-malleability">Proof Malleability</a></h3>
<p>Groth16 proofs are <strong>malleable</strong>: given a valid proof $(\pi_A, \pi_B, \pi_C)$, the tuple $(-\pi_A, -\pi_B, \pi_C)$ is also valid for the same statement. This follows from the verification equation; negating both $\pi_A$ and $\pi_B$ preserves the pairing product since $e(-\pi_A, -\pi_B) = e(\pi_A, \pi_B)$.</p>
<p><strong>Malleability is not forgery.</strong> This distinction is important. Malleability allows an attacker to change the <em>appearance</em> of a valid proof (flipping signs), but not the <em>content</em>. They cannot change the public inputs or the witness. It is like taking a valid check and folding it in half: it is still a valid check for the same amount, but the physical object has changed. This matters for transaction IDs (which often hash the proof), but not for the validity of the statement itself.</p>
<p>This matters for applications that use proofs as unique identifiers or assume proof uniqueness (e.g., preventing double-spending by rejecting duplicate proofs). Mitigations include hashing the proof into the transaction identifier, or requiring proof elements to lie in a specific half of the group.</p>
<h2 id="trusted-setup-practical-considerations"><a class="header" href="#trusted-setup-practical-considerations">Trusted Setup: Practical Considerations</a></h2>
<p>The circuit-specific setup is Groth16's most significant operational constraint.</p>
<h3 id="what-toxic-waste-means"><a class="header" href="#what-toxic-waste-means">What &quot;Toxic Waste&quot; Means</a></h3>
<p>The secrets $\tau, \alpha, \beta, \gamma, \delta$ must be destroyed after the ceremony. If any participant retains them:</p>
<ul>
<li>Knowing $\tau$ breaks binding: allows computing arbitrary polynomial evaluations</li>
<li>Knowing $\alpha, \beta, \delta$ allows forging proofs for false statements</li>
</ul>
<p>The secrets are called &quot;toxic waste&quot; because their existence post-ceremony compromises all proofs using that SRS.</p>
<h3 id="multi-party-ceremonies"><a class="header" href="#multi-party-ceremonies">Multi-Party Ceremonies</a></h3>
<p>Production deployments (Zcash, Tornado Cash) run MPC ceremonies with many participants:</p>
<ol>
<li>Participant $i$ receives current parameters</li>
<li>Generates random $t_i$, updates parameters by raising to power $t_i$</li>
<li>Publishes updated parameters</li>
<li>Proves they performed the update correctly (via a proof of knowledge)</li>
<li>Deletes $t_i$</li>
</ol>
<p>The final secrets are products of all participants' contributions. Security holds if any participant was honest.</p>
<p>The ceremonies themselves became rituals of paranoid care. In the original Zcash &quot;Powers of Tau&quot; ceremony (2017-2018), participants generated randomness from radioactive decay, atmospheric noise, and the movements of lava lamps. One contributor drove through the Canadian wilderness to avoid network surveillance while computing their contribution on an air-gapped laptop. Another broadcast their parameters from a remote location and then physically destroyed the hard drive on video. The ceremonies were not theater (or not <em>only</em> theater). The security guarantee depends on at least one participant successfully destroying their secret. Every act of destruction was an attempt to make the toxic waste irrecoverable by any means: forensic, computational, or coercive.</p>
<h3 id="phase-2-complexity"><a class="header" href="#phase-2-complexity">Phase 2 Complexity</a></h3>
<p>Phase 1 (Powers of Tau) is performed once per maximum circuit size and reused indefinitely.</p>
<p>Phase 2 requires:</p>
<ul>
<li>Computing circuit-specific elements for every wire</li>
<li>MPC ceremony among willing participants</li>
<li>Verification that each contribution was correct</li>
</ul>
<p><strong>The DNA Mixer.</strong> Think of Phase 2 as mixing the circuit's DNA into the randomness. Every wire in the circuit needs its own specific $\tau$-powered handle so the prover can &quot;grab&quot; it during proof generation. If the circuit has 10,000 wires, the setup must produce 10,000 specific handles: one for each wire's contribution to the $A$, $B$, and $C$ polynomials. This is why the setup grows linearly with circuit size; you are baking the circuit's structure into the cryptographic parameters.</p>
<p>For a circuit with $n$ wires, Phase 2 generates $O(n)$ group elements. Large circuits require large ceremonies.</p>
<h3 id="when-circuit-specific-setup-is-acceptable"><a class="header" href="#when-circuit-specific-setup-is-acceptable">When Circuit-Specific Setup Is Acceptable</a></h3>
<p>Groth16 makes sense when:</p>
<ol>
<li><strong>The circuit is fixed</strong>: Same computation proved repeatedly (e.g., confidential transactions)</li>
<li><strong>Proof size dominates costs</strong>: On-chain verification where bytes are expensive</li>
<li><strong>Verification speed is critical</strong>: Applications requiring &lt;10ms verification</li>
<li><strong>Trust model is manageable</strong>: Established communities can coordinate ceremonies</li>
</ol>
<p>It makes less sense when:</p>
<ol>
<li><strong>Circuits change frequently</strong>: Development, iteration, bug fixes</li>
<li><strong>Many different circuits needed</strong>: General-purpose computation</li>
<li><strong>No trusted community exists</strong>: Public good infrastructure without coordination</li>
</ol>
<h2 id="comparison-with-universal-snarks"><a class="header" href="#comparison-with-universal-snarks">Comparison with Universal SNARKs</a></h2>
<p>Since 2016, the field has developed universal SNARKs: systems with a single trusted setup reusable across circuits.</p>
<h3 id="plonk-chapter-13"><a class="header" href="#plonk-chapter-13">PLONK (Chapter 13)</a></h3>
<ul>
<li><strong>Setup</strong>: Universal, updatable</li>
<li><strong>Proof size</strong>: ~400-500 bytes (with KZG)</li>
<li><strong>Verification</strong>: ~10ms (several pairings)</li>
<li><strong>Prover</strong>: Comparable to Groth16</li>
</ul>
<p>PLONK trades 3-4x larger proofs for the ability to prove any circuit without new ceremonies.</p>
<h3 id="marlinsonic"><a class="header" href="#marlinsonic">Marlin/Sonic</a></h3>
<p>These are universal SNARKs that emerged around the same time as PLONK. <strong>Sonic</strong> (2019) pioneered the &quot;universal and updateable&quot; trusted setup: a single ceremony works for any circuit up to a size bound, and users can add their own randomness to strengthen trust. <strong>Marlin</strong> (2020) keeps R1CS arithmetization (like Groth16) but achieves universality through algebraic holographic proofs. Both have similar proof sizes to PLONK (~500 bytes) but different verification costs and prover trade-offs. In practice, PLONK's flexibility and ecosystem support led to wider adoption.</p>
<h3 id="starks-chapter-15"><a class="header" href="#starks-chapter-15">STARKs (Chapter 15)</a></h3>
<ul>
<li><strong>Setup</strong>: Transparent (no trusted setup)</li>
<li><strong>Proof size</strong>: ~100 KB</li>
<li><strong>Verification</strong>: ~10-50ms (hash-based)</li>
<li><strong>Prover</strong>: Faster than pairing-based systems</li>
</ul>
<p>STARKs eliminate trust assumptions entirely but with much larger proofs.</p>
<h3 id="the-trade-off-summary"><a class="header" href="#the-trade-off-summary">The Trade-Off Summary</a></h3>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Setup</th><th>Proof Size</th><th>Verification</th><th>Security Model</th></tr></thead><tbody>
<tr><td>Groth16</td><td>Circuit-specific</td><td>128 bytes</td><td>3 pairings</td><td>Generic Group</td></tr>
<tr><td>PLONK+KZG</td><td>Universal</td><td>~500 bytes</td><td>~10 pairings</td><td>q-SDH</td></tr>
<tr><td>PLONK+IPA</td><td>Transparent</td><td>~10 KB</td><td>O(n)</td><td>DLog</td></tr>
<tr><td>STARKs</td><td>Transparent</td><td>~100 KB</td><td>O(logÂ²n)</td><td>Hash collision</td></tr>
</tbody></table>
</div>
<p>Groth16 remains optimal when proof size is the binding constraint and circuit stability justifies the setup cost.</p>
<h2 id="implementation-considerations"><a class="header" href="#implementation-considerations">Implementation Considerations</a></h2>
<h3 id="curve-selection"><a class="header" href="#curve-selection">Curve Selection</a></h3>
<p>Groth16 requires pairing-friendly curves. Common choices:</p>
<p><strong>BN254 (alt_bn128)</strong>:</p>
<ul>
<li>254-bit prime field</li>
<li>Fast pairing computation</li>
<li>Ethereum precompiles at addresses 0x06, 0x07, 0x08</li>
<li>~100 bits of security (debated; some analyses suggest less)</li>
</ul>
<p><strong>BLS12-381</strong>:</p>
<ul>
<li>381-bit prime field</li>
<li>Higher security (~120 bits)</li>
<li>Slower pairings</li>
<li>Used by Zcash Sapling, Ethereum 2.0 BLS signatures</li>
</ul>
<h3 id="prover-complexity"><a class="header" href="#prover-complexity">Prover Complexity</a></h3>
<p>The prover performs:</p>
<ul>
<li>$O(n)$ scalar multiplications to form witness polynomials from basis polynomials</li>
<li>$O(n \log n)$ operations for polynomial multiplication and division (computing $H(X)$)</li>
<li>Multi-scalar multiplications (MSM) to compute proof elements</li>
</ul>
<p>The MSM dominates for large circuits. Significant engineering effort goes into MSM optimization: Pippenger's algorithm, parallelization, GPU acceleration.</p>
<h3 id="on-chain-verification"><a class="header" href="#on-chain-verification">On-Chain Verification</a></h3>
<p>Ethereum's precompiled contracts enable efficient Groth16 verification:</p>
<ul>
<li><code>ecAdd</code> (0x06): Elliptic curve addition in $\mathbb{G}_1$</li>
<li><code>ecMul</code> (0x07): Scalar multiplication in $\mathbb{G}_1$</li>
<li><code>ecPairing</code> (0x08): Multi-pairing check</li>
</ul>
<p>A typical Groth16 verifier contract:</p>
<ol>
<li>Computes $\text{vk}_x$ via ecMul and ecAdd for each public input</li>
<li>Calls ecPairing with four pairs: $(-\pi_A, \pi_B), (vk_\alpha, vk_\beta), (vk_x, vk_\gamma), (\pi_C, vk_\delta)$</li>
<li>Returns true if the pairing product equals 1</li>
</ol>
<p>Gas cost: ~200,000-300,000 gas depending on public input count.</p>
<h2 id="historical-significance"><a class="header" href="#historical-significance">Historical Significance</a></h2>
<p>Groth16 was published in 2016, building on a decade of SNARK research.</p>
<p><strong>Predecessors</strong>:</p>
<ul>
<li>Pinocchio (2013): First practical SNARK, 8 group elements, 11 pairings</li>
<li>GGPR13: Quadratic span programs, similar approach</li>
<li>BCTV14: Linear PCPs, precursor to Groth16's analysis</li>
</ul>
<p><strong>Groth16's Innovations</strong>:</p>
<ol>
<li>Reduced proof to 3 elements (from 8)</li>
<li>Reduced verification to 3 pairings (from 11)</li>
<li>Proved near-optimality via lower bounds</li>
<li>Refined Linear PCP analysis</li>
</ol>
<p><strong>Impact</strong>:</p>
<ul>
<li>Deployed in Zcash (Sapling upgrade, 2018)</li>
<li>Standard for blockchain applications requiring minimal proof size</li>
<li>Baseline against which new systems are compared</li>
</ul>
<p>The paper's title, &quot;On the Size of Pairing-based Non-interactive Arguments,&quot; reflects its focus on the theoretical question: how small can proofs be?</p>
<h2 id="worked-example-complete-trace"><a class="header" href="#worked-example-complete-trace">Worked Example: Complete Trace</a></h2>
<p>Let's trace through a minimal example: proving knowledge of $x$ such that $x^2 = 9$.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p><strong>Circuit</strong>: One multiplication gate: $x \times x = 9$</p>
<p><strong>Witness structure</strong>: $Z = (1, 9, x)$ where $z_0 = 1$ (constant), $z_1 = 9$ (public output), $z_2 = x$ (private input)</p>
<p><strong>R1CS</strong> (single constraint):</p>
<ul>
<li>$A = (0, 0, 1)$, selects $x$</li>
<li>$B = (0, 0, 1)$, selects $x$</li>
<li>$C = (0, 1, 0)$, selects output</li>
</ul>
<p><strong>Evaluation point</strong>: $\omega_1 = 1$</p>
<p><strong>Basis polynomials</strong> (constants, since only one constraint):</p>
<ul>
<li>$A_0(X) = 0$, $A_1(X) = 0$, $A_2(X) = 1$</li>
<li>$B_0(X) = 0$, $B_1(X) = 0$, $B_2(X) = 1$</li>
<li>$C_0(X) = 0$, $C_1(X) = 1$, $C_2(X) = 0$</li>
</ul>
<p><strong>Vanishing polynomial</strong>: $Z_H(X) = X - 1$</p>
<h3 id="prover-computation-with-x--3"><a class="header" href="#prover-computation-with-x--3">Prover Computation (with $x = 3$)</a></h3>
<p><strong>Witness</strong>: $Z = (1, 9, 3)$</p>
<p><strong>Witness polynomials</strong>:</p>
<ul>
<li>$A(X) = z_2 \cdot A_2(X) = 3 \cdot 1 = 3$</li>
<li>$B(X) = z_2 \cdot B_2(X) = 3 \cdot 1 = 3$</li>
<li>$C(X) = z_1 \cdot C_1(X) = 9 \cdot 1 = 9$</li>
</ul>
<p><strong>QAP check</strong>: $A(X) \cdot B(X) - C(X) = 9 - 9 = 0$</p>
<p>The polynomial is identically zero, so $H(X) = 0$.</p>
<p><strong>Proof elements</strong> (with random $r, s$):</p>
<ul>
<li>$\pi_A = g_1^{\alpha + 3 + r\delta}$</li>
<li>$\pi_B = g_2^{\beta + 3 + s\delta}$</li>
<li>$\pi_C = g_1^{\frac{3(\beta + \alpha)}{\delta} + s(\alpha + 3 + r\delta) + r(\beta + 3 + s\delta) - rs\delta}$</li>
</ul>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p><strong>Public input</strong>: $z_1 = 9$</p>
<p><strong>Compute $\text{vk}_x$</strong>: The verification key contains public input consistency elements $(\text{vk}_{IC})_j = g_1^{(\beta A_j(\tau) + \alpha B_j(\tau) + C_j(\tau))/\gamma}$ for each public index $j$. In our circuit, $j = 0$ (constant) and $j = 1$ (public output). Since $A_0 = A_1 = B_0 = B_1 = C_0 = 0$ and $C_1 = 1$:</p>
<p>$$\text{vk}<em>x = (\text{vk}</em>{IC})<em>0 + z_1 \cdot (\text{vk}</em>{IC})_1 = g_1^{0/\gamma} + 9 \cdot g_1^{1/\gamma} = g_1^{9/\gamma}$$</p>
<p><strong>Pairing check</strong>: The verifier computes four pairings and confirms their product equals 1 in $\mathbb{G}_T$.</p>
<p>If $x \neq \pm 3$, the QAP would not hold, $H(X)$ would not exist as a polynomial, and the pairing check would fail.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<ol>
<li>
<p><strong>Optimal proof size.</strong> Three group elements: 128 bytes on BN254. This is the theoretical minimum for pairing-based SNARKs; Groth proved no system in this model can do better.</p>
</li>
<li>
<p><strong>QAP transformation.</strong> R1CS constraints become a polynomial divisibility condition: $A(X) \cdot B(X) - C(X) = H(X) \cdot Z_H(X)$. Satisfiability at $m$ evaluation points becomes divisibility by the vanishing polynomial.</p>
</li>
<li>
<p><strong>Pairing verification.</strong> One pairing equation checks the entire polynomial identity homomorphically. Verification is $O(1)$: constant time regardless of circuit size.</p>
</li>
<li>
<p><strong>Linear PCP foundation.</strong> The prover's messages are linear combinations of SRS elements. This linearity constraint is what enables the 3-element proof: the prover can only compute what the setup allows.</p>
</li>
</ol>
<h3 id="setup-and-trust"><a class="header" href="#setup-and-trust">Setup and Trust</a></h3>
<ol start="5">
<li>
<p><strong>Circuit-specific setup.</strong> Phase 1 (powers of tau) is universal; Phase 2 embeds the circuit's basis polynomials into the SRS. Changing a single gate invalidates the entire Phase 2.</p>
</li>
<li>
<p><strong>Trust model.</strong> 1-of-N honesty: if any participant in the ceremony destroys their toxic waste, the setup is secure. Multi-party computation makes this practical; Zcash's ceremony had hundreds of participants.</p>
</li>
</ol>
<h3 id="security-properties"><a class="header" href="#security-properties">Security Properties</a></h3>
<ol start="7">
<li>
<p><strong>Blinding for zero-knowledge.</strong> Random scalars $r, s$ and setup secrets $\alpha, \beta, \delta$ blind the proof elements. The blinding is algebraically woven into the protocol, not layered on top.</p>
</li>
<li>
<p><strong>Generic group model.</strong> Security assumes adversaries cannot exploit the group's structure beyond the allowed operations. This is a stronger assumption than standard models, but enables maximum efficiency.</p>
</li>
</ol>
<h3 id="context-and-deployment"><a class="header" href="#context-and-deployment">Context and Deployment</a></h3>
<ol start="9">
<li>
<p><strong>Ecosystem role.</strong> The standard choice when proof size dominates cost: on-chain verification (gas costs scale with proof size), bandwidth-constrained settings, and applications requiring constant-size proofs.</p>
</li>
<li>
<p><strong>Historical milestone.</strong> Published 2016, deployed in Zcash Sapling 2018. Established the benchmark against which all subsequent SNARKs are measured. Still the smallest proof size achievable without changing the cryptographic model.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="11-the-snark-recipe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="13-plonk.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="11-the-snark-recipe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="13-plonk.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
