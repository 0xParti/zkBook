<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Commitment Schemes - Minimizing Trust, Maximizing Truth</title>


        <!-- Custom HTML head -->
        <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams']}
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          },
          loader: {
            load: ['[tex]/ams']
          }
        };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
          mermaid.initialize({ startOnLoad: false, theme: 'dark' });
        
          document.addEventListener('DOMContentLoaded', function() {
            // Transform mdBook's code blocks into Mermaid-compatible format
            document.querySelectorAll('pre code.language-mermaid').forEach(function(codeBlock) {
              const pre = codeBlock.parentElement;
              const div = document.createElement('div');
              div.className = 'mermaid';
              div.textContent = codeBlock.textContent;
              pre.parentElement.replaceChild(div, pre);
            });
            mermaid.run();
          });
        </script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Architecture of Verifiable Secrets - A comprehensive guide to Zero-Knowledge Proofs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="01-the-trust-problem.html"><strong aria-hidden="true">1.</strong> The Trust Problem</a></li><li class="chapter-item expanded "><a href="02-the-alchemical-power-of-polynomials.html"><strong aria-hidden="true">2.</strong> The Alchemical Power of Polynomials</a></li><li class="chapter-item expanded "><a href="03-the-sum-check-protocol.html"><strong aria-hidden="true">3.</strong> The Sum-Check Protocol</a></li><li class="chapter-item expanded "><a href="04-multilinear-extensions.html"><strong aria-hidden="true">4.</strong> Multilinear Extensions</a></li><li class="chapter-item expanded "><a href="05-univariate-polynomials-and-finite-fields.html"><strong aria-hidden="true">5.</strong> Univariate Polynomials and Finite Fields</a></li><li class="chapter-item expanded "><a href="06-commitment-schemes.html" class="active"><strong aria-hidden="true">6.</strong> Commitment Schemes</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocols</li><li class="chapter-item expanded "><a href="07-the-gkr-protocol.html"><strong aria-hidden="true">7.</strong> The GKR Protocol</a></li><li class="chapter-item expanded "><a href="08-from-circuits-to-polynomials.html"><strong aria-hidden="true">8.</strong> From Circuits to Polynomials</a></li><li class="chapter-item expanded "><a href="09-polynomial-commitment-schemes.html"><strong aria-hidden="true">9.</strong> Polynomial Commitment Schemes</a></li><li class="chapter-item expanded "><a href="10-hash-based-commitments-and-fri.html"><strong aria-hidden="true">10.</strong> Hash-Based Commitments and FRI</a></li><li class="chapter-item expanded affix "><li class="part-title">SNARK Construction</li><li class="chapter-item expanded "><a href="11-the-snark-recipe.html"><strong aria-hidden="true">11.</strong> The SNARK Recipe</a></li><li class="chapter-item expanded "><a href="12-groth16.html"><strong aria-hidden="true">12.</strong> Groth16</a></li><li class="chapter-item expanded "><a href="13-plonk.html"><strong aria-hidden="true">13.</strong> PLONK</a></li><li class="chapter-item expanded "><a href="14-lookup-arguments.html"><strong aria-hidden="true">14.</strong> Lookup Arguments</a></li><li class="chapter-item expanded "><a href="15-starks.html"><strong aria-hidden="true">15.</strong> STARKs</a></li><li class="chapter-item expanded affix "><li class="part-title">Zero-Knowledge</li><li class="chapter-item expanded "><a href="16-sigma-protocols.html"><strong aria-hidden="true">16.</strong> Sigma Protocols</a></li><li class="chapter-item expanded "><a href="17-the-zero-knowledge-property.html"><strong aria-hidden="true">17.</strong> The Zero-Knowledge Property</a></li><li class="chapter-item expanded "><a href="18-making-proofs-zero-knowledge.html"><strong aria-hidden="true">18.</strong> Making Proofs Zero-Knowledge</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="19-fast-sum-check-proving.html"><strong aria-hidden="true">19.</strong> Fast Sum-Check Proving</a></li><li class="chapter-item expanded "><a href="20-minimizing-commitment-costs.html"><strong aria-hidden="true">20.</strong> Minimizing Commitment Costs</a></li><li class="chapter-item expanded "><a href="21-the-two-classes-of-piops.html"><strong aria-hidden="true">21.</strong> The Two Classes of PIOPs</a></li><li class="chapter-item expanded "><a href="22-composition-and-recursion.html"><strong aria-hidden="true">22.</strong> Composition and Recursion</a></li><li class="chapter-item expanded "><a href="23-choosing-a-snark.html"><strong aria-hidden="true">23.</strong> Choosing a SNARK</a></li><li class="chapter-item expanded affix "><li class="part-title">Broader Context</li><li class="chapter-item expanded "><a href="24-mpc-and-zk-parallel-paths.html"><strong aria-hidden="true">24.</strong> MPC and ZK Parallel Paths</a></li><li class="chapter-item expanded "><a href="25-frontiers-and-open-problems.html"><strong aria-hidden="true">25.</strong> Frontiers and Open Problems</a></li><li class="chapter-item expanded "><a href="26-zk-in-the-cryptographic-landscape.html"><strong aria-hidden="true">26.</strong> ZK in the Cryptographic Landscape</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendix-a-cryptographic-primitives.html"><strong aria-hidden="true">27.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="appendix-b-historical-timeline.html"><strong aria-hidden="true">28.</strong> Historical Timeline</a></li><li class="chapter-item expanded "><a href="appendix-c-field-equations-cheat-sheet.html"><strong aria-hidden="true">29.</strong> Field Equations Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Minimizing Trust, Maximizing Truth</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/0xParti/zkBook/edit/main/web/src/06-commitment-schemes.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-6-commitment-schemes-cryptographic-binding"><a class="header" href="#chapter-6-commitment-schemes-cryptographic-binding">Chapter 6: Commitment Schemes: Cryptographic Binding</a></h1>
<p>In 1981, Manuel Blum posed a simple question: can two people play a fair game of coin-flipping over the telephone?</p>
<p>Blum was working on what cryptographers called <strong>Mental Poker</strong>: how can two people play a card game over the phone without a trusted dealer? How do I know you didn't shuffle the Aces to the top of the deck? The coin flip was the atomic unit of this problem. Get that right, and you could build up to full card games.</p>
<p>The problem seems impossible. Alice flips a coin and announces &quot;heads.&quot; Bob has no way to verify she actually flipped anything. She might have waited to hear his guess first. Or she might change her answer after hearing his response. Without shared physical reality, without a coin both parties can see, how can either trust the outcome?</p>
<p>Blum's solution introduced one of the most fundamental primitives in cryptography. Alice doesn't announce her flip directly. Instead, she first sends a <em>commitment</em>: a cryptographic object that locks in her choice without revealing it. Only after Bob makes his guess does Alice <em>open</em> the commitment, proving what she had chosen all along. The commitment is binding (Alice cannot change her answer after sending it) and hiding (Bob learns nothing until the reveal).</p>
<p>This two-phase structure, commit then reveal, turns out to be exactly what our proof systems need. You've designed a protocol where the prover claims a polynomial evaluates to some value, and you want to check this with random queries. But the prover responds <em>after</em> seeing your challenge. What stops them from constructing a fake polynomial that happens to pass your spot-checks?</p>
<p>This is the <strong>binding problem</strong>. The verifier's randomness is meant to catch a cheating prover off-guard. But if the prover can adapt their answers after seeing the challenge, they can tailor responses to pass. The polynomial identity testing that underlies our protocols becomes meaningless.</p>
<p>We need a mechanism that forces the prover to fix their polynomial before verification begins.</p>
<h2 id="the-trust-problem-revisited"><a class="header" href="#the-trust-problem-revisited">The Trust Problem Revisited</a></h2>
<p>Consider the sum-check protocol from Chapter 3. The verifier sends random challenges $r_1, r_2, \ldots$, and the prover responds with univariate polynomials. At the end, the verifier must check that some claimed evaluation matches the actual polynomial. But how does the verifier know the prover didn't just fabricate a polynomial that happens to satisfy the final check?</p>
<p>The issue is subtle. Our soundness proofs assumed the prover is committed to <em>some</em> polynomial before the interaction begins. But in a raw interactive protocol, nothing enforces this. A dishonest prover could:</p>
<ol>
<li>Wait to see all the verifier's challenges</li>
<li>Work backwards to construct a polynomial that passes</li>
<li>Claim they had this polynomial all along</li>
</ol>
<p>This attack doesn't violate the <em>information-theoretic</em> soundness of the protocol; it violates the <em>execution model</em>. We assumed a sequential game where the prover moves first; in reality, we need cryptography to enforce this ordering.</p>
<h2 id="the-commitment-paradigm"><a class="header" href="#the-commitment-paradigm">The Commitment Paradigm</a></h2>
<p>A <strong>commitment scheme</strong> solves this problem through a two-phase protocol:</p>
<p><strong>Phase 1 (Commit)</strong>: The prover publishes a <em>commitment</em>, a short, seemingly random string that binds them to a value without revealing it.</p>
<p><strong>Phase 2 (Reveal)</strong>: Later, the prover can open the commitment by revealing the original value. Anyone can verify that the revealed value matches the original commitment.</p>
<p><strong>Formal Properties</strong>:</p>
<ul>
<li>
<p><strong>Binding</strong>: Once committed, the committer cannot open to a different value. More precisely, no efficient adversary can find two different values that produce the same commitment.</p>
</li>
<li>
<p><strong>Hiding</strong>: The commitment reveals nothing about the committed value. An observer cannot distinguish between commitments to different values.</p>
</li>
</ul>
<p>These properties exist in tension. Perfect binding means each value maps to a unique commitment, but then the commitment might leak information about the value. Perfect hiding means commitments are statistically indistinguishable, but then multiple values might share commitments. Cryptographic schemes typically achieve one property perfectly and the other computationally.</p>
<h2 id="pedersen-commitments-the-discrete-log-approach"><a class="header" href="#pedersen-commitments-the-discrete-log-approach">Pedersen Commitments: The Discrete Log Approach</a></h2>
<p>The most elegant commitment scheme comes from a surprising source: the hardness of computing discrete logarithms in cyclic groups.</p>
<p><strong>Setup</strong>: Let $G$ be a cyclic group of prime order $q$ (think of an elliptic curve group). Select two generators $g$ and $h$ such that <em>nobody knows</em> the discrete logarithm $\log_g h$. The public parameters are $(G, q, g, h)$.</p>
<p><strong>Commit</strong>: To commit to a value $m \in \mathbb{Z}_q$, the committer:</p>
<ol>
<li>Chooses a random <em>blinding factor</em> $r \leftarrow \mathbb{Z}_q$</li>
<li>Computes the commitment $C = g^m \cdot h^r$</li>
</ol>
<p><strong>Reveal</strong>: To open, the committer reveals $(m, r)$. The verifier checks that $g^m \cdot h^r = C$.</p>
<p>The scheme uses multiplicative notation, but on elliptic curves (the dominant implementation), we write $C = m \cdot G + r \cdot H$ using additive notation.</p>
<h3 id="why-binding-holds"><a class="header" href="#why-binding-holds">Why Binding Holds</a></h3>
<p>Suppose Alice commits $C = g^m h^r$ and later wants to open it as a <em>different</em> value $m' \neq m$. She needs to find $r'$ such that:
$$g^m h^r = g^{m'} h^{r'}$$</p>
<p>Rearranging:
$$g^{m - m'} = h^{r' - r}$$</p>
<p>This means:
$$\log_g h = \frac{m - m'}{r' - r}$$</p>
<p>But computing $\log_g h$ is the discrete logarithm problem! If Alice could find such $(m', r')$, she could break DLog in $G$. The binding property holds computationally, as long as discrete log is hard.</p>
<h3 id="why-hiding-holds"><a class="header" href="#why-hiding-holds">Why Hiding Holds</a></h3>
<p>The commitment $C = g^m h^r$ is <strong>perfectly hiding</strong>. Here's the key insight: since $r$ is uniformly random in $\mathbb{Z}_q$, and $h$ is a generator of $G$, the term $h^r$ is uniformly distributed over all of $G$.</p>
<p>For any message $m$, the commitment $C = g^m \cdot h^r$ is a uniformly random group element. This means:</p>
<ul>
<li>$\text{Commitment to } m_1 \sim \text{Uniform}(G)$</li>
<li>$\text{Commitment to } m_2 \sim \text{Uniform}(G)$</li>
</ul>
<p>The two distributions are identical: not just computationally indistinguishable, but <em>statistically</em> identical. Even an unbounded adversary cannot determine the committed value from the commitment alone.</p>
<p><strong>The Paint Analogy.</strong> Think of $g^m$ as a specific color of paint (say, blue for $m = 10$). Think of $h^r$ as a random bucket of paint mixed in. Because $h^r$ can be <em>any</em> color depending on $r$, adding it to blue produces a mixture that looks essentially random. If you see purple, it could be blue + red, or yellow + violet. Without knowing the exact shade of the random mixer ($r$), the original color ($m$) is completely masked.</p>
<h3 id="the-independence-requirement"><a class="header" href="#the-independence-requirement">The Independence Requirement</a></h3>
<p>There's a critical subtlety: the generators $g$ and $h$ must be <em>independently chosen</em> such that nobody knows $\log_g h$.</p>
<p>If Alice knows that $h = g^x$ for some $x$, she can break binding:
$$C = g^m h^r = g^m (g^x)^r = g^{m + xr}$$</p>
<p>She can open this as $(m', r')$ for any $m'$ by computing $r' = r + (m - m')/x$. The verification passes because:
$$g^{m'} h^{r'} = g^{m'} g^{x(r + (m - m')/x)} = g^{m' + xr + m - m'} = g^{m + xr} = C$$</p>
<p>If Alice knows this relationship $h = g^x$, she holds a <strong>trapdoor</strong>. It allows her to open the commitment to <em>any</em> value she wants. This is why trusted setups in SNARKs are so sensitive: if the creator knows the &quot;toxic waste&quot; (the secret exponents used to generate the parameters), they can forge proofs. We prevent this by generating $g$ and $h$ from &quot;nothing-up-my-sleeve&quot; numbers like the digits of $\pi$ or by hashing different strings to curve points, ensuring nobody knows the discrete log relationship.</p>
<h2 id="worked-example-pedersen-commitment-in-mathbbz_23"><a class="header" href="#worked-example-pedersen-commitment-in-mathbbz_23">Worked Example: Pedersen Commitment in $\mathbb{Z}_{23}^*$</a></h2>
<p>Let's trace through a concrete example using the multiplicative group modulo 23.</p>
<p><strong>Setup</strong>: Work in $\mathbb{Z}_{23}^*$, which has order $\phi(23) = 22$. Take generators $g = 5$ and $h = 7$. We assume nobody knows $\log_5 7$.</p>
<p><strong>Commitment to $m = 10$</strong>:</p>
<ul>
<li>Choose random blinding factor $r = 3$</li>
<li>Compute $C = g^m \cdot h^r = 5^{10} \cdot 7^3 \pmod{23}$</li>
</ul>
<p>Computing $5^{10} \pmod{23}$:</p>
<ul>
<li>$5^2 = 25 \equiv 2$</li>
<li>$5^4 \equiv 4$</li>
<li>$5^8 \equiv 16$</li>
<li>$5^{10} = 5^8 \cdot 5^2 \equiv 16 \cdot 2 = 32 \equiv 9$</li>
</ul>
<p>Computing $7^3 \pmod{23}$:</p>
<ul>
<li>$7^2 = 49 \equiv 3$</li>
<li>$7^3 = 7 \cdot 3 = 21$</li>
</ul>
<p>So $C = 9 \cdot 21 = 189 \equiv 5 \pmod{23}$.</p>
<p><strong>Verification</strong>: Given $(m = 10, r = 3)$, the verifier checks:
$$5^{10} \cdot 7^3 \equiv 9 \cdot 21 \equiv 5 \pmod{23} ; \checkmark$$</p>
<p>The commitment opens correctly.</p>
<h2 id="the-homomorphic-property"><a class="header" href="#the-homomorphic-property">The Homomorphic Property</a></h2>
<p>Pedersen commitments have a remarkable algebraic property: they are <strong>additively homomorphic</strong>. You can compute on committed values without knowing what they are.</p>
<p>Given two commitments:
$$C_1 = g^{m_1} h^{r_1} \quad \text{and} \quad C_2 = g^{m_2} h^{r_2}$$</p>
<p>Their product is:
$$C_1 \cdot C_2 = g^{m_1} h^{r_1} \cdot g^{m_2} h^{r_2} = g^{m_1 + m_2} h^{r_1 + r_2}$$</p>
<p>This is a valid commitment to $m_1 + m_2$ with blinding factor $r_1 + r_2$!</p>
<p><strong>Worked Example (continuing)</strong>:</p>
<p>Commit to $m_2 = 4$ with $r_2 = 6$:
$$C_2 = 5^4 \cdot 7^6 \pmod{23}$$</p>
<p>Computing $5^4 \equiv 4$ and $7^6 = (7^3)^2 \equiv 21^2 = 441 \equiv 441 - 19 \cdot 23 = 441 - 437 = 4$.</p>
<p>So $C_2 = 4 \cdot 4 = 16$.</p>
<p><strong>Homomorphic addition</strong>:
$$C_3 = C_1 \cdot C_2 = 5 \cdot 16 = 80 \equiv 80 - 3 \cdot 23 = 80 - 69 = 11 \pmod{23}$$</p>
<p>This should be a commitment to $m_1 + m_2 = 14$ with blinding factor $r_1 + r_2 = 9$.</p>
<p><strong>Verification</strong>:
$$5^{14} \cdot 7^9 \pmod{23}$$</p>
<p>For $5^{14} = 5^{10} \cdot 5^4 \equiv 9 \cdot 4 = 36 \equiv 13$.</p>
<p>For $7^9 = 7^6 \cdot 7^3 \equiv 4 \cdot 21 = 84 \equiv 84 - 3 \cdot 23 = 84 - 69 = 15$.</p>
<p>So $5^{14} \cdot 7^9 \equiv 13 \cdot 15 = 195 \equiv 195 - 8 \cdot 23 = 195 - 184 = 11 \pmod{23}$.</p>
<p>It matches $C_3 = 11$.</p>
<p>This property is extraordinarily useful. A verifier can combine multiple commitments, add constants, or compute linear combinations, all without learning the committed values. This enables protocols where computations happen &quot;in the encrypted domain.&quot;</p>
<h2 id="scalar-multiplication"><a class="header" href="#scalar-multiplication">Scalar Multiplication</a></h2>
<p>The homomorphic property extends to scalar multiplication. For a constant $k$:
$$(C)^k = (g^m h^r)^k = g^{km} h^{kr}$$</p>
<p>This is a commitment to $k \cdot m$ with blinding factor $k \cdot r$. The verifier can scale committed values without opening them.</p>
<h2 id="from-scalar-to-vector-commitments"><a class="header" href="#from-scalar-to-vector-commitments">From Scalar to Vector Commitments</a></h2>
<p>The Pedersen scheme naturally extends from committing to a single value to committing to an entire vector. Given $n$ independent generators $G_1, \ldots, G_n$ and a blinding generator $H$, we can commit to a vector $\vec{m} = (m_1, \ldots, m_n)$:</p>
<p>$$C = \sum_{i=1}^n m_i \cdot G_i + r \cdot H$$</p>
<p>This <strong>Pedersen vector commitment</strong> is still a single group element, regardless of the vector length. The homomorphic property extends: adding two vector commitments yields a commitment to the component-wise sum.</p>
<p>But here's where things get interesting for our purposes. Recall from Chapters 4 and 5 that a polynomial evaluation is just an inner product:
$$f(z) = \sum_{i=0}^{n-1} c_i z^i = \langle \vec{c}, \vec{z} \rangle$$</p>
<p>where $\vec{c} = (c_0, \ldots, c_{n-1})$ are the coefficients and $\vec{z} = (1, z, z^2, \ldots, z^{n-1})$ is the evaluation vector.</p>
<p>If we commit to the coefficient vector using a Pedersen vector commitment, we've effectively committed to the polynomial itself. And thanks to homomorphism, the verifier can compute a commitment to any evaluation $f(z)$ without knowing the coefficients!</p>
<p>This observation, that polynomial evaluation is inner product and inner products interact beautifully with homomorphic commitments, is the conceptual bridge from simple commitments to full polynomial commitment schemes. We'll cross that bridge in Chapter 9.</p>
<h2 id="proving-knowledge-of-an-opening"><a class="header" href="#proving-knowledge-of-an-opening">Proving Knowledge of an Opening</a></h2>
<p>A commitment alone proves nothing; the prover must eventually reveal the opening to be useful. But what if we want to prove something <em>about</em> the committed value without revealing it?</p>
<p>This is where $\Sigma$-protocols (Chapter 16) enter the picture. A prover who knows the opening $(m, r)$ for a commitment $C = g^m h^r$ can convince a verifier they know this opening without revealing $m$ or $r$.</p>
<p>The protocol follows the classic three-move structure:</p>
<p><strong>Round 1 (Commit to randomness)</strong>: The prover picks random $d, s \leftarrow \mathbb{Z}_q$ and sends $T = g^d h^s$.</p>
<p><strong>Round 2 (Challenge)</strong>: The verifier sends a random challenge $e \leftarrow \mathbb{Z}_q$.</p>
<p><strong>Round 3 (Response)</strong>: The prover computes:</p>
<ul>
<li>$z_1 = d + e \cdot m$</li>
<li>$z_2 = s + e \cdot r$</li>
</ul>
<p>and sends $(z_1, z_2)$.</p>
<p><strong>Verification</strong>: The verifier checks:
$$g^{z_1} h^{z_2} \stackrel{?}{=} T \cdot C^e$$</p>
<p><strong>Why it works</strong>: Expanding the right side:
$$T \cdot C^e = (g^d h^s) \cdot (g^m h^r)^e = g^{d + em} h^{s + er} = g^{z_1} h^{z_2}$$</p>
<p>The equation holds if the prover knows $(m, r)$.</p>
<p><strong>Why it's zero-knowledge</strong>: The values $z_1$ and $z_2$ look random because they're masked by the truly random $d$ and $s$. The verifier learns nothing about $m$ or $r$ beyond the fact that the prover knows them.</p>
<p><strong>Why it's sound</strong>: A prover who doesn't know $(m, r)$ cannot answer two different challenges $e$ and $e'$ consistently. Given two accepting transcripts with the same $T$ but different challenges, one can extract the witness; this is the &quot;special soundness&quot; property.</p>
<h2 id="worked-example-proof-of-knowledge"><a class="header" href="#worked-example-proof-of-knowledge">Worked Example: Proof of Knowledge</a></h2>
<p>Continuing our example with $g = 5$, $h = 7$ in $\mathbb{Z}_{23}^*$, suppose the prover committed $C = 5$ and claims to know the opening.</p>
<p><strong>Prover's commitment</strong>:</p>
<ul>
<li>Choose random $d = 8$, $s = 2$</li>
<li>Compute $T = 5^8 \cdot 7^2 \pmod{23}$</li>
<li>$5^8 \equiv 16$, $7^2 = 49 \equiv 3$</li>
<li>$T = 16 \cdot 3 = 48 \equiv 2$</li>
</ul>
<p><strong>Verifier's challenge</strong>: $e = 4$</p>
<p><strong>Prover's response</strong> (recall $m = 10$, $r = 3$):</p>
<ul>
<li>$z_1 = d + e \cdot m = 8 + 4 \cdot 10 = 48 \equiv 48 \pmod{22} = 4$ (arithmetic mod group order)</li>
<li>$z_2 = s + e \cdot r = 2 + 4 \cdot 3 = 14$</li>
</ul>
<p><strong>Verification</strong>:</p>
<ul>
<li>
<p>Left side: $5^4 \cdot 7^{14} \pmod{23}$</p>
<ul>
<li>$5^4 \equiv 4$</li>
<li>$7^{14} = 7^{11} \cdot 7^3$ (since $14 \equiv 14 \pmod{22}$)</li>
<li>$7^{11} = 7^8 \cdot 7^3$. We have $7^2 \equiv 3$, $7^4 \equiv 9$, $7^8 \equiv 81 \equiv 81 - 3 \cdot 23 = 12$</li>
<li>$7^{11} = 12 \cdot 21 = 252 \equiv 252 - 10 \cdot 23 = 22 \equiv -1$</li>
<li>$7^{14} = (-1) \cdot 21 = -21 \equiv 2$</li>
<li>Left side: $4 \cdot 2 = 8$</li>
</ul>
</li>
<li>
<p>Right side: $T \cdot C^e = 2 \cdot 5^4 \pmod{23}$</p>
<ul>
<li>$5^4 \equiv 4$</li>
<li>Right side: $2 \cdot 4 = 8$</li>
</ul>
</li>
</ul>
<p>Both sides equal 8. The proof verifies.</p>
<h2 id="beyond-pedersen-a-landscape-of-commitment-schemes"><a class="header" href="#beyond-pedersen-a-landscape-of-commitment-schemes">Beyond Pedersen: A Landscape of Commitment Schemes</a></h2>
<p>Pedersen commitments are beautiful but not the only option. Different commitment schemes offer different trade-offs:</p>
<p><strong>Hash-Based Commitments</strong>: Commit as $C = H(m | r)$ where $H$ is a cryptographic hash. Binding follows from collision resistance; hiding follows from the hash acting as a random oracle. These are simple and quantum-resistant, but they lack the homomorphic property.</p>
<p><strong>Polynomial Commitments</strong>: The heart of modern SNARKs. Instead of committing to a single value, we commit to an entire polynomial and can later prove evaluations at arbitrary points. Chapter 9 explores KZG (using pairings) and IPA (using discrete log) in depth.</p>
<p><strong>ElGamal-style Commitments</strong>: Related to encryption, where the commitment can be &quot;decrypted&quot; with a secret key. Useful in some multi-party protocols.</p>
<p>Each scheme involves trade-offs between:</p>
<ul>
<li><strong>Setup</strong>: Does it require a trusted setup?</li>
<li><strong>Assumptions</strong>: Discrete log? Pairings? Hashes?</li>
<li><strong>Efficiency</strong>: Commitment size, proof size, computation time</li>
<li><strong>Properties</strong>: Homomorphic? Additively? Multiplicatively?</li>
<li><strong>Quantum resistance</strong>: Will it survive quantum computers?</li>
</ul>
<h2 id="why-commitments-matter-for-zk-proofs"><a class="header" href="#why-commitments-matter-for-zk-proofs">Why Commitments Matter for ZK Proofs</a></h2>
<p>We opened this chapter with the binding problem: how do we ensure the prover doesn't cheat by choosing their polynomial after seeing the verifier's challenges?</p>
<p>Commitment schemes provide the answer through the <strong>commit-and-prove</strong> paradigm:</p>
<ol>
<li>
<p><strong>Commit phase</strong>: Before any interaction, the prover commits to their polynomial (or the witness encoding it).</p>
</li>
<li>
<p><strong>Interaction phase</strong>: The verifier sends challenges, the prover responds. But the prover's polynomial was fixed in step 1.</p>
</li>
<li>
<p><strong>Opening phase</strong>: At the end, the prover opens relevant parts of their commitment. The verifier checks consistency.</p>
</li>
</ol>
<p>The binding property ensures the prover cannot change their polynomial mid-protocol. The hiding property ensures the commitment itself doesn't leak information about the witness. Every modern SNARK (Groth16, PLONK, STARKs) follows this pattern, varying only in which commitment scheme they use (KZG for Groth16/PLONK, Merkle trees for STARKs).</p>
<h2 id="the-hiding-binding-tradeoff"><a class="header" href="#the-hiding-binding-tradeoff">The Hiding-Binding Tradeoff</a></h2>
<p>There's a fundamental tension in commitment schemes that deserves attention: you cannot have both <em>perfect</em> hiding and <em>perfect</em> binding simultaneously.</p>
<p><strong>Perfect binding</strong> means each commitment corresponds to exactly one value: no two distinct messages ever produce the same commitment. This is an information-theoretic guarantee: even with unlimited computation, opening to a different value is impossible.</p>
<p><strong>Perfect hiding</strong> means the commitment reveals nothing about the value: all messages produce statistically indistinguishable commitment distributions. Again, this is information-theoretic: even unbounded adversaries learn nothing.</p>
<p>Why can't we have both? Consider what each requires:</p>
<ul>
<li>
<p>Perfect binding needs the commitment function to be injective (one-to-one). Every value maps to a unique commitment.</p>
</li>
<li>
<p>Perfect hiding needs all commitments to look identical regardless of the input. The commitment must be independent of the value.</p>
</li>
</ul>
<p>These requirements conflict. If commitments are independent of values (hiding), multiple values must map to the same commitment (not binding). If every value has a unique commitment (binding), the commitment reveals which value was chosen (not hiding).</p>
<p><strong>The resolution</strong>: Relax one property to <em>computational</em> rather than <em>information-theoretic</em>:</p>
<ul>
<li>
<p><strong>Perfectly hiding, computationally binding</strong>: Pedersen commitments. As we proved earlier, for any message $m$ there exists an $r$ that produces any given commitment, so an unbounded adversary cannot determine which value is inside. But finding two openings requires solving discrete log, so binding holds against efficient adversaries. Even an all-powerful being cannot tell which value is committed (perfect hiding), but a quantum computer could eventually break the lock (computational binding).</p>
</li>
<li>
<p><strong>Perfectly binding, computationally hiding</strong>: Hash-based commitments $C = H(m | r)$. A hash function is deterministic: each $(m, r)$ pair maps to exactly one commitment, and collision resistance means you cannot find two pairs that collide. The value is locked in tight (perfect binding). But an unbounded adversary could brute-force all possible inputs to find $(m, r)$ (computational hiding).</p>
</li>
</ul>
<p>This tradeoff shapes the design space. For ZK proofs, we typically want hiding (don't reveal the witness) and accept computational binding (secure against poly-time adversaries). Pedersen commitments are the natural choice: the witness stays perfectly hidden, and binding holds as long as discrete log is hard.</p>
<h2 id="looking-ahead"><a class="header" href="#looking-ahead">Looking Ahead</a></h2>
<p>We've established the cryptographic primitive that makes succinct proofs possible. Commitments transform interactive protocols, where timing and ordering are honor-system, into cryptographically enforced games where cheating is computationally infeasible.</p>
<p>In Chapter 9, we'll see how polynomial commitment schemes (KZG, IPA, and FRI) extend these ideas to commit to polynomials and prove evaluations. These are the engines that power modern SNARKs.</p>
<p>But first, we need to understand <em>what</em> we're proving. Chapter 7 introduces the GKR protocol, which uses sum-check to verify layered arithmetic circuits. And Chapter 8 shows how arbitrary computations become circuits, which become polynomials. Together, these chapters complete the story of how a computation becomes a succinct proof.</p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ol>
<li>
<p><strong>The binding problem</strong>: Interactive proofs need cryptographic enforcement to prevent provers from adapting their answers to verifier challenges.</p>
</li>
<li>
<p><strong>Commitment = seal</strong>: A commitment locks in a value before revealing it; binding ensures it can't change, hiding ensures it reveals nothing.</p>
</li>
<li>
<p><strong>Pedersen commitments</strong>: $C = g^m h^r$ achieves perfect hiding (statistically) and computational binding (from discrete log hardness).</p>
</li>
<li>
<p><strong>Independence is critical</strong>: The generators $g$ and $h$ must have unknown discrete log relationship, or binding fails.</p>
</li>
<li>
<p><strong>Homomorphic magic</strong>: Pedersen commitments allow addition in the &quot;encrypted domain&quot;: $C_1 \cdot C_2$ commits to $m_1 + m_2$.</p>
</li>
<li>
<p><strong>Vector commitments</strong>: Committing to a coefficient vector effectively commits to a polynomial.</p>
</li>
<li>
<p><strong>Proof of knowledge</strong>: Sigma protocols let a prover demonstrate they know a commitment's opening without revealing it.</p>
</li>
<li>
<p><strong>Commit-and-prove paradigm</strong>: The foundation of all modern SNARKs: commit first, then prove properties of the committed values.</p>
</li>
<li>
<p><strong>Trade-off landscape</strong>: Different commitment schemes offer different balances of setup requirements, assumptions, efficiency, and quantum resistance.</p>
</li>
<li>
<p><strong>Bridge to polynomial commitments</strong>: The observation that evaluation = inner product connects scalar commitments to the polynomial commitment schemes that power SNARKs.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="05-univariate-polynomials-and-finite-fields.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="07-the-gkr-protocol.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="05-univariate-polynomials-and-finite-fields.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="07-the-gkr-protocol.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
